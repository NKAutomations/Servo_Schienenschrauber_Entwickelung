<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_Schrauber_PnP_Neu_1" Id="{27017add-3654-423b-bdd0-24cd6af9ea31}" SpecialFunc="None">
    <Declaration><![CDATA[// Überarbeitete Version mit vollständiger NC-Achsenintegration
(*
ABLAUFBESCHREIBUNG SERVOSCHRAUBER MIT NC-ACHSENANBINDUNG:

1. INITIALISIERUNG (Step 0)
   - Reset aller Ausgänge und Variablen
   - Prüfung der Grundbedingungen

2. STARTBEDINGUNGEN (Step 10)
   - Prüfung aller Freigaben und Sicherheitsbedingungen
   - Überprüfung des Schutzbereichs und NC-Status

3. ACHSEN-INITIALISIERUNG (Step 20)
   - Modulo-Betrieb aktivieren
   - Istwert auf 0 setzen
   - Drehmomentgrenzwert setzen

4. SCHRAUBHUB (Step 30)
   - Vorfahren des Schraubhubs
   - Überwachung des Zustellzylinders

5. DREHZAHLRAMPE (Step 45)
   - Kontrollierte Beschleunigung
   - Überwachung der erreichten Geschwindigkeit

6. HAUPTSCHRAUBVORGANG (Step 50/60)
   - Überwachung von Drehmoment und Tiefe
   - Geschwindigkeitsanpassung je nach Tiefe

7. DREHMOMENTÜBERWACHUNG (Step 65)
   - Mittelwertbildung des Drehmoments
   - Behandlung der vier Schraubfälle

8. ACHSEN-STOPP (Step 70)
   - Kontrolliertes Stoppen der Achse
   - Warten auf Stillstand

9. ABSCHLUSS (Step 80-95)
   - Rückfahrt in Grundstellung
   - Referenzierung bei Bedarf

10. FEHLERBEHANDLUNG (Step -1)
    - Zentrale Fehlerbehandlung
    - Achsen-Reset bei Bedarf
*)
FUNCTION_BLOCK FB_Schrauber_PnP_Neu_1
VAR_INPUT
	I_bResetTeststation				: BOOL;		(* Hinzugefügt für Testaufbau im Steuerungstechniker Büro um den Baustein zu Quittieren !!*)
    // Grundlegende Steuerungseingänge
    I_bTaktFrg               : BOOL;          // Freigabe für Takt
    I_bTaktStop              : BOOL;          // Stopp des Takts
    I_bAuto                  : BOOL;          // Automatikbetrieb
    I_bHand                  : BOOL;          // Handbetrieb
    I_bQuittFehler          : BOOL;          // Fehlerquittierung
    I_bGrundstellung        : BOOL;          // Grundstellungsanforderung
    I_bSchutzbereichOK      : BOOL;          // Schutzbereich freigegeben

    // Prozesseingänge
    I_bTaktStart            : BOOL;          // Start Schraubvorgang
    I_bTaktStartHalb        : BOOL;          // Start Halbschraubvorgang
    I_bGrdstlgSchrEinh      : BOOL;          // Grundstellung Schraubeinheit
    I_bZustellZylAusgef     : BOOL;          // Zustellzylinder ausgefahren

    // Parameter
    I_fSchraubTiefeAuswurf  : LREAL;         // Auswurftiefe
    I_fTiefentoleranzPos    : LREAL := 1.0;  // Positive Tiefentoleranz
    I_fTiefentoleranzNeg    : LREAL := 0.5;  // Negative Tiefentoleranz
    I_nAchsId               : INT;           // Achsen-ID für Schraubmotor
    I_nEncId                : INT;           // Encoder-ID für Tiefenmessung
    I_stParam               : ST_ParamSKSServoschrauber; // Parameter
    I_tAutoQuit             : TIME := T#0MS; // Automatische Quittierzeit
    
    // Steuerungseingänge
    I_bSchraubeNachschiessen: BOOL;          // Nachschiessen aktiv
    I_bReferenzfahrtAktiv   : BOOL;          // Referenzfahrt aktiv
    I_bFreigabeAuswerfen    : BOOL;          // Freigabe Auswerfen
    I_bSchrauberLogOn       : BOOL;          // Schrauber Logging aktiv
    I_nMotorHersteller      : INT;           // Motorhersteller (0:BRC, 1:Beckhoff)
    I_bHuettenSchr          : BOOL := FALSE; // Hüttenhölscher Schrauber aktiv
END_VAR

VAR_OUTPUT
    // Statusausgänge
    Q_bBusy                 : BOOL;          // Baustein aktiv
    Q_bDone                 : BOOL;          // Vorgang abgeschlossen
    Q_bError                : BOOL;          // Fehler aufgetreten
    Q_sPosZustand          : STRING := '';   // Aktueller Positionszustand
    Q_bGrundstellungAktiv  : BOOL;          // Grundstellung wird angefahren
    Q_bGrundstellungOk     : BOOL;          // Grundstellung erreicht
    
    // Prozessausgänge
    Q_bSchraubHub          : BOOL;           // Schraubhub aktiv
    Q_bSchrAuswurf         : BOOL;           // Auswurf aktiv
    Q_bSchrHalt            : BOOL;           // Schrauber gestoppt
    Q_bAxisReset           : BOOL;           // Achsreset angefordert
    Q_nErrorId             : INT;            // Fehler-ID
    Q_bDrehmomentFehler    : BOOL;           // Drehmomentfehler aufgetreten
    Q_nTorque			 	: INT:=300;
	
    // Debug und Status
    Q_nStep                : INT;            // Aktueller Schritt
    Q_strStep              : STRING;         // Schrittbeschreibung
    Q_sStatus              : STRING(255);    // Statustext
END_VAR

VAR_IN_OUT
    IQ_fbObjSchlauch       : FB_Obj_IOSchlauch;        // Schlauch
    IQ_stMeldung           : ST_MeldServoSchrauber_1;  // Meldung
END_VAR

VAR
    // Achsen-Istwerte (aus NC gelesen)
    fSchraubTiefeIst       : LREAL;          // Aktuelle Schraubtiefe
    fDrehmomentIst         : INT;            // Aktuelles Drehmoment in 0.1%
    fDrehzahlIst           : LREAL;          // Aktuelle Drehzahl
    
    // Sollwerte für Achse
    fSchraubTiefeSoll      : LREAL;          // Soll-Schraubtiefe
    fDrehzahlSoll          : LREAL;          // Solldrehzahl in %
    fDrehmomentGrenzwert   : LREAL;            // Drehmomentgrenzwert in 0.1%
    
    // Toleranzen und Grenzwerte
    fTiefenToleranz        : LREAL := 0.1;   // Toleranz für Tiefenmessung (mm)
    fMaxSpeed              : LREAL := 100.0; // Maximale Drehzahl (%)
    fReducedSpeed          : LREAL := 5.0;   // Reduzierte Drehzahl (%)
    fMaxTorque             : LREAL := 2000;    // Max Drehmoment (200.0%)
    fTorqueIncrement       : LREAL := 200;     // Drehmomenterhöhung (20.0%)
    
    // Rampenparameter
    tRampeHoch            : TIME := T#500MS; // Beschleunigungszeit
    fTiefeDrehzahlRed     : LREAL := 2.0;    // Abstand für Drehzahlreduzierung
    
    // Überwachungsvariablen
    fTiefenAenderung      : LREAL;           // Tiefenänderung über Zeit
    fLetzteTiefe          : LREAL;           // Letzte gemessene Tiefe
    nFehlerCounter        : INT;             // Fehlerzähler
    arrDrehmomentIst      : ARRAY [0..10] OF LREAL; // Array für Mittelwertbildung
    fDrehmomentIstMittel  : LREAL;             // Gemitteltes Drehmoment
    
    // Timer
    tonRampe              : TON;             // Timer für Rampensteuerung
    tonUeberwachung       : TON;             // Überwachungstimer
    tonStillstand         : TON;             // Stillstandsüberwachung
    tonGeschwindigkeit    : TON;             // Timer für Geschwindigkeitsüberwachung
    
    // Statusinformationen
    nSchraubFall          : INT;             // Aktueller Schraubfall (1-4)
    bSchraubphaseAktiv    : BOOL;            // Schraubphase aktiv
    bDrehmomentErreicht   : BOOL;            // Solldrehmoment erreicht
    bTiefenAenderungOK    : BOOL;            // Tiefenänderung im Toleranzbereich
    bAchseInitialisiert   : BOOL;            // Achse wurde initialisiert
    
    // Flankenmerker
    rtrigStart            : R_TRIG;          // Flanke für Start
    ftrigQuitt            : F_TRIG;          // Flanke für Quittierung
    
    // Index für Mittelwertbildung
    idx                   : INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Flankenauswertung
rtrigStart(CLK:=I_bTaktStart);
ftrigQuitt(CLK:=I_bQuittFehler);

// Achsen-Istwerte kontinuierlich lesen
ReadAxisValues();

// Achsenfehler überwachen
CheckAxisErrors();

IF I_bResetTeststation
THEN
	Q_nStep := 0;
END_IF

// Hauptablauf
CASE Q_nStep OF
    
    // Initialisierung
    0: 
        Q_strStep := 'Initialisierung';
        ResetOutputs();
        IF I_bTaktFrg AND NOT I_bGrundstellung AND (I_bTaktStart OR rtrigStart.Q) THEN
            Q_nStep := 10;
            Q_bBusy := TRUE;
        END_IF

    // Start und Prüfung der Grundbedingungen
    10: 
        Q_strStep := 'Grundbedingungen prüfen';
		CheckStartConditions();
        IF CheckStartConditions() THEN
            // Parameter übernehmen
            fSchraubTiefeSoll := I_stParam.fParam_Sollschraubtiefe;
            fDrehmomentGrenzwert := I_stParam.fParam_Sollmoment; // 140.0% Startdrehmoment
            Q_nStep := 20;
        END_IF

    // Achsen-Initialisierung
    20:
        Q_strStep := 'Achse initialisieren';
        InitializeAxis();
        IF bAchseInitialisiert THEN
            Q_nStep := 30;
        END_IF

    // Schraubhub vorfahren
    30: 
        Q_strStep := 'Schraubhub vorfahren';
        Q_bSchraubHub := TRUE;
        tonUeberwachung(IN:=TRUE, PT:=I_stParam.tParam_ZeitdSchraubhubSchr);
        IF I_bZustellZylAusgef THEN
            tonUeberwachung(IN:=FALSE);
            Q_nStep := 40;
        ELSIF tonUeberwachung.Q THEN
            Q_bError := TRUE;
            Q_nErrorId := 80; // Fehler Schrauberstange
            Q_nStep := -1;
        END_IF

    // Auswerfhub vor (Tiefe prüfen)
    40:
        Q_strStep := 'Tiefe beim Aufsetzen prüfen';
        ExecuteTiefenPruefung();
        // Prüfen ob Schraube vorhanden
        IF fSchraubTiefeIst < (fSchraubTiefeSoll - 10.0) THEN
            nFehlerCounter := nFehlerCounter + 1;
            IF nFehlerCounter >= 2 THEN
                Q_bError := TRUE;
                Q_nErrorId := 40; // Schraube fehlt
                Q_nStep := -1;
            ELSE
                Q_nStep := 80; // Nochmal versuchen
            END_IF
        ELSE
            Q_nStep := 45;
        END_IF

    // Drehzahlrampe hochfahren
    45:
        Q_strStep := 'Drehzahl hochrampen';
        StartSpeedRamp();
        // Prüfen ob Geschwindigkeit erreicht
        IF CheckSpeedReached() THEN
            Q_nStep := 50;
        ELSIF tonGeschwindigkeit.Q THEN
            Q_bError := TRUE;
            Q_nErrorId := 45; // Geschwindigkeit nicht erreicht
            Q_nStep := -1;
        END_IF

    // Hauptschraubvorgang - schnelle Fahrt
    50:
        Q_strStep := 'Hauptschraubvorgang';
        ExecuteMainScrewing();
        // Prüfen ob Umschalttiefe erreicht
        IF fSchraubTiefeIst >= (I_stParam.fParam_Umschalttiefe - fTiefeDrehzahlRed) THEN
            Q_nStep := 60;
        END_IF

    // Tiefenabfrage und Drehzahlreduktion
    60:
        Q_strStep := 'Drehzahl reduzieren für Endposition';
        ReduceSpeed();
        IF CheckFinalPosition() THEN
            Q_nStep := 65;
        END_IF

    // Drehmomentüberwachung
    65:
        Q_strStep := 'Drehmomentüberwachung';
        MonitorTorque();
        DetermineSchraubfall();
        
        CASE nSchraubFall OF
            1: HandleCase1();
            2: HandleCase2();
            3: HandleCase3();
            4: HandleCase4();
        END_CASE
        
        // Prüfen ob Vorgang erfolgreich abgeschlossen
        IF CheckFinishConditions() THEN
            Q_nStep := 70;
        END_IF

    // Schraubvorgang beenden - Achse stoppen
    70:
        Q_strStep := 'Achse stoppen';
        StopAxis();
        IF arrNcAchsen[I_nAchsId].stStatus.bInStillst THEN
            Q_nStep := 75;
        END_IF

    // Warten und Stillstand sicherstellen
    75:
        Q_strStep := 'Warten auf Stillstand';
        tonStillstand(IN:=TRUE, PT:=T#100MS);
        IF tonStillstand.Q THEN
            tonStillstand(IN:=FALSE);
            Q_nStep := 80;
        END_IF

    // Schraubhub zurückfahren
    80:
        Q_strStep := 'Schraubhub zurück';
        Q_bSchraubHub := FALSE;
        Q_bSchrAuswurf := FALSE;
        tonUeberwachung(IN:=TRUE, PT:=T#500MS);
        IF tonUeberwachung.Q OR I_bGrdstlgSchrEinh THEN
            tonUeberwachung(IN:=FALSE);
            Q_nStep := 90;
        END_IF

    // Grundstellung anfahren
    90:
        Q_strStep := 'Grundstellung anfahren';
        ReturnToHome();
        IF I_bGrdstlgSchrEinh THEN
            Q_nStep := 95;
        END_IF

    // Referenzierung wenn nötig
    95:
        Q_strStep := 'Referenzierung';
        ReferenceAxis();
        IF arrNcAchsen[I_nAchsId].stEinAusG.I_nSignalstatuswort.0 OR I_nMotorHersteller = 1 THEN
            Q_bDone := TRUE;
            Q_bBusy := FALSE;
            Q_nStep := 0;
        END_IF

    // Fehlerbehandlung
    -1:
        Q_strStep := Q_sPosZustand;
        HandleError();
        IF ftrigQuitt.Q OR (I_tAutoQuit > T#0MS AND tonStillstand.Q) THEN
            ResetAxis();
            ResetOutputs();
            Q_nStep := 0;
        END_IF
END_CASE

// Timer für automatische Quittierung
IF Q_nStep = -1 AND I_tAutoQuit > T#0MS THEN
    tonStillstand(IN:=TRUE, PT:=I_tAutoQuit);
ELSE
    tonStillstand(IN:=FALSE);
END_IF

Q_nTorque	:=	LREAL_TO_INT(fDrehmomentGrenzwert);
// Grundstellung
Q_bGrundstellungOk := I_bGrdstlgSchrEinh AND Q_nStep = 0;

// Statusausgabe
Q_sStatus := CONCAT('Step ', INT_TO_STRING(Q_nStep));
Q_sStatus := CONCAT(Q_sStatus, ': ');
Q_sStatus := CONCAT(Q_sStatus, Q_strStep);]]></ST>
    </Implementation>
    <Method Name="CheckAxisErrors" Id="{11111111-2222-3333-4444-555555555555}">
      <Declaration><![CDATA[METHOD CheckAxisErrors
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// NC-Fehler überwachen
IF arrNcAchsen[I_nAchsId].bNcFehler THEN
    Q_bError := TRUE;
    Q_nErrorId := 100; // NC-Fehler
    Q_strStep := CONCAT('NC-Fehler: ', DWORD_TO_STRING(arrNcAchsen[I_nAchsId].nFehlerNr));
END_IF

// DC-Status überwachen (Bit 13 = Antriebsfehler)
IF arrNcAchsen[I_nAchsId].stEinAusG.I_nDCStatusword.13 THEN
    Q_bError := TRUE;
    Q_nErrorId := 101; // Antriebsfehler
    Q_strStep := 'Antriebsfehler am Regler';
END_IF

// Positionsfreigabe verloren während Fahrt
IF Q_nStep >= 45 AND Q_nStep <= 70 THEN
    IF NOT arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg THEN
        Q_bError := TRUE;
        Q_nErrorId := 102; // Positionsfreigabe verloren
        Q_strStep := 'Positionsfreigabe verloren';
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckFinalPosition" Id="{33333333-4444-5555-6666-777777777777}">
      <Declaration><![CDATA[METHOD CheckFinalPosition : BOOL
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Prüfen ob Endposition erreicht wurde
CheckFinalPosition := fSchraubTiefeIst >= (fSchraubTiefeSoll - I_fTiefentoleranzNeg);

IF CheckFinalPosition THEN
    // Drehzahl auf Anzugsgeschwindigkeit reduzieren
    arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := fReducedSpeed;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckFinishConditions" Id="{22222222-3333-4444-5555-666666666666}">
      <Declaration><![CDATA[METHOD CheckFinishConditions : BOOL
VAR
    bDepthOK : BOOL;
    bTorqueOK : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Prüfen der Abschlussbedingungen
bDepthOK := (fSchraubTiefeIst >= (fSchraubTiefeSoll - I_fTiefentoleranzNeg)) AND 
            (fSchraubTiefeIst <= (fSchraubTiefeSoll + I_fTiefentoleranzPos));

bTorqueOK := (fDrehmomentIstMittel >= (fDrehmomentGrenzwert * 0.9)) AND 
             (fDrehmomentIstMittel <= fMaxTorque);

CheckFinishConditions := bDepthOK AND bTorqueOK;

IF CheckFinishConditions THEN
    Q_strStep := 'Schraubvorgang erfolgreich abgeschlossen';
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckSpeedReached" Id="{44444444-5555-6666-7777-888888888888}">
      <Declaration><![CDATA[METHOD CheckSpeedReached : BOOL
VAR
    fTargetSpeed : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Timer für Überwachung
tonGeschwindigkeit(IN:=TRUE, PT:=T#3S);

// Zielgeschwindigkeit berechnen (80% der Sollgeschwindigkeit)
fTargetSpeed := I_stParam.fStartDrehzahl * 0.8;

// Prüfen ob Geschwindigkeit erreicht wurde
CheckSpeedReached := arrNcAchsen[I_nAchsId].stStatus.bFaehrtPos AND
                     (arrNcAchsen[I_nAchsId].fVeloIstwert >= 
                      (fTargetSpeed * arrNcAchsen[I_nAchsId].stParam.fEilgGeschw / 100));

IF CheckSpeedReached THEN
    tonGeschwindigkeit(IN:=FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckStartConditions" Id="{55555555-6666-7777-8888-999999999999}">
      <Declaration><![CDATA[METHOD CheckStartConditions : BOOL
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckStartConditions := 
    I_bTaktFrg AND
    NOT I_bTaktStop AND
    I_bSchutzbereichOK AND
    NOT Q_bError AND
    I_bGrdstlgSchrEinh AND  // Grundstellung muss erreicht sein
    arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg AND  // Achse hat Positionsfreigabe
    NOT arrNcAchsen[I_nAchsId].bNcFehler;  // Keine NC-Fehler
        
IF NOT CheckStartConditions THEN
    IF NOT I_bSchutzbereichOK THEN
        Q_strStep := 'Warte auf Schutzbereich';
    ELSIF NOT I_bGrdstlgSchrEinh THEN
        Q_strStep := 'Warte auf Grundstellung';
    ELSIF NOT arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg THEN
        Q_strStep := 'Warte auf Achsenfreigabe';
    ELSIF arrNcAchsen[I_nAchsId].bNcFehler THEN
        Q_strStep := 'NC-Fehler aktiv';
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="DetermineSchraubfall" Id="{66666666-7777-8888-9999-aaaaaaaaaaaa}">
      <Declaration><![CDATA[METHOD DetermineSchraubfall
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Bestimmung des aktuellen Schraubfalls
IF fSchraubTiefeIst < (fSchraubTiefeSoll - 10.0) THEN
    // Fall 4: Keine Schraube (große Tiefenabweichung)
    nSchraubFall := 4;
ELSIF bDrehmomentErreicht AND NOT bTiefenAenderungOK THEN
    // Fall 1: Drehmoment erreicht, aber Tiefe ändert sich noch
    IF fSchraubTiefeIst < fSchraubTiefeSoll THEN
        nSchraubFall := 1;
    ELSE
        nSchraubFall := 3; // Positive Toleranz
    END_IF
ELSIF bTiefenAenderungOK AND NOT bDrehmomentErreicht THEN
    // Fall 2: Tiefe erreicht, aber Drehmoment nicht
    nSchraubFall := 2;
ELSE
    // Normalfall
    nSchraubFall := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecuteMainScrewing" Id="{77777777-8888-9999-aaaa-bbbbbbbbbbbb}">
      <Declaration><![CDATA[METHOD ExecuteMainScrewing
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Hauptschraubvorgang mit voller Geschwindigkeit
arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fParam_Solldrehzahl;
arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode := MC_BlendingNext;
arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;

// Drehmomentüberwachung
bDrehmomentErreicht := fDrehmomentIstMittel >= fDrehmomentGrenzwert;

// Tiefenänderung überwachen
fTiefenAenderung := ABS(fSchraubTiefeIst - fLetzteTiefe);
bTiefenAenderungOK := fTiefenAenderung < 0.1; // Stillstand wenn < 0.1mm Änderung

// Speichern für nächsten Zyklus
fLetzteTiefe := fSchraubTiefeIst;

// Überwachung auf maximales Drehmoment
IF fDrehmomentIstMittel >= fMaxTorque THEN
    Q_bError := TRUE;
    Q_nErrorId := 65; // Drehmoment überschritten
    Q_nStep := -1;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecuteTiefenPruefung" Id="{88888888-9999-aaaa-bbbb-cccccccccccc}">
      <Declaration><![CDATA[METHOD ExecuteTiefenPruefung
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Auswerfhub aktivieren um Tiefe zu prüfen
Q_bSchrAuswurf := TRUE;
tonUeberwachung(IN:=TRUE, PT:=I_stParam.tParam_ZeitdSchraubhubSchr);

// Tiefe beim Aufsetzen speichern
IF tonUeberwachung.ET > T#100MS AND tonUeberwachung.ET < T#200MS THEN
    fLetzteTiefe := fSchraubTiefeIst;
END_IF

// Timeout-Überwachung
IF tonUeberwachung.Q THEN
    tonUeberwachung(IN:=FALSE);
    Q_bError := TRUE;
    Q_nErrorId := 80; // Fehler Schrauberstange
    Q_nStep := -1;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleCase1" Id="{99999999-aaaa-bbbb-cccc-dddddddddddd}">
      <Declaration><![CDATA[METHOD HandleCase1
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Fall 1: Negative Materialtoleranzen & Drehmoment erreicht
IF bDrehmomentErreicht AND NOT bTiefenAenderungOK THEN
    IF fDrehmomentGrenzwert < fMaxTorque THEN
        // Drehmoment schrittweise erhöhen
        fDrehmomentGrenzwert := fDrehmomentGrenzwert + fTorqueIncrement;
        arrNcAchsen[I_nAchsId].stEinAusG.Q_nDrehmomentGrenzwert := LREAL_TO_INT(fDrehmomentGrenzwert);
        arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := fReducedSpeed;
        Q_strStep := 'Erhöhe Drehmoment';
    ELSE
        // Maximales Drehmoment erreicht
        Q_bError := TRUE;
        Q_nErrorId := 65;
        Q_nStep := -1;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleCase2" Id="{aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee}">
      <Declaration><![CDATA[METHOD HandleCase2
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Fall 2: Negative Materialtoleranzen & Solltiefe erreicht
IF bTiefenAenderungOK AND NOT bDrehmomentErreicht THEN
    IF fDrehmomentIstMittel < (fDrehmomentGrenzwert / 2) THEN
        // Drehmoment viel zu niedrig - Fehler
        Q_bError := TRUE;
        Q_nErrorId := 2;
        Q_strStep := 'Drehmoment nicht erreicht';
        Q_nStep := -1;
    ELSE
        // Leicht reduziertes Drehmoment akzeptabel
        arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := fReducedSpeed;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleCase3" Id="{bbbbbbbb-cccc-dddd-eeee-ffffffffffff}">
      <Declaration><![CDATA[METHOD HandleCase3
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Fall 3: Positive Materialtoleranzen
IF bDrehmomentErreicht AND NOT bTiefenAenderungOK THEN
    IF fDrehmomentGrenzwert < fMaxTorque THEN
        fDrehmomentGrenzwert := fDrehmomentGrenzwert + fTorqueIncrement;
        arrNcAchsen[I_nAchsId].stEinAusG.Q_nDrehmomentGrenzwert := LREAL_TO_INT(fDrehmomentGrenzwert);
        arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := fReducedSpeed;
        Q_strStep := 'Positive Toleranz - Erhöhe Drehmoment';
    ELSE
        // Prüfen ob Tiefe trotzdem OK
        IF fSchraubTiefeIst >= (fSchraubTiefeSoll - I_fTiefentoleranzNeg) THEN
            // Akzeptabel
            Q_nStep := 70;
        ELSE
            Q_bError := TRUE;
            Q_nErrorId := 60; // Solltiefe nicht erreicht
            Q_nStep := -1;
        END_IF
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleCase4" Id="{cccccccc-dddd-eeee-ffff-111111111111}">
      <Declaration><![CDATA[METHOD HandleCase4
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Fall 4: Keine Schraube
IF fSchraubTiefeIst < (fSchraubTiefeSoll - 10.0) THEN
    nFehlerCounter := nFehlerCounter + 1;
    Q_strStep := CONCAT('Keine Schraube erkannt - Versuch ', INT_TO_STRING(nFehlerCounter));
    
    IF nFehlerCounter >= 2 THEN
        Q_bError := TRUE;
        Q_nErrorId := 40; // Schraube fehlt
        Q_strStep := 'Bitte Schraubsystem prüfen - Schraube fehlt';
        Q_nStep := -1;
    ELSE
        // Nochmal versuchen
        Q_nStep := 80; // Zurück zur Grundstellung
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleError" Id="{dddddddd-eeee-ffff-1111-222222222222}">
      <Declaration><![CDATA[METHOD HandleError
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Fehlerbehandlung
Q_bError := TRUE;
Q_bSchraubHub := FALSE;
Q_bSchrAuswurf := FALSE;
Q_bSchrHalt := TRUE;

// Achse stoppen
arrStartAusf[I_nAchsId].I_bAchseStopPos := TRUE;
arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;

// Fehlerbeschreibung setzen
CASE Q_nErrorId OF
    2: // Drehmoment nicht erreicht
        Q_sPosZustand := 'Fehler: Drehmoment nicht erreicht';
        Q_bDrehmomentFehler := TRUE;
        
    40: // Schraube fehlt
        Q_sPosZustand := 'Fehler: Schraube fehlt';
        
    45: // Geschwindigkeit nicht erreicht
        Q_sPosZustand := 'Fehler: Geschwindigkeit nicht erreicht';
        
    60: // Solltiefe nicht erreicht
        Q_sPosZustand := 'Fehler: Solltiefe nicht erreicht';
        
    61: // Solltiefe überschritten
        Q_sPosZustand := 'Fehler: Solltiefe überschritten';
        
    65: // Drehmoment überschritten
        Q_sPosZustand := 'Fehler: Drehmoment überschritten';
        Q_bDrehmomentFehler := TRUE;
        
    80: // Fehler Schrauberstange
        Q_sPosZustand := 'Fehler: Schrauberstange/Zustellzylinder';
        
    100: // NC-Fehler
        Q_sPosZustand := 'Fehler: NC-Achse';
        
    101: // Antriebsfehler
        Q_sPosZustand := 'Fehler: Antrieb/Regler';
        
    102: // Positionsfreigabe verloren
        Q_sPosZustand := 'Fehler: Positionsfreigabe verloren';
        
    ELSE
        Q_sPosZustand := CONCAT('Fehler: Code ', INT_TO_STRING(Q_nErrorId));
END_CASE

// Meldungen setzen
UpdateErrorMessages();]]></ST>
      </Implementation>
    </Method>
    <Method Name="InitializeAxis" Id="{eeeeeeee-ffff-1111-2222-333333333333}">
      <Declaration><![CDATA[METHOD InitializeAxis
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Achse für Schraubvorgang initialisieren
bAchseInitialisiert := FALSE;

// Modulo-Betrieb aktivieren
arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := TRUE;

// Istwert auf 0 setzen
arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := TRUE;
arrNcAchsen[I_nAchsId].stGrdfkt.fIstSetzwert := 0;

// Drehmomentgrenzwert setzen
arrNcAchsen[I_nAchsId].stEinAusG.Q_nDrehmomentGrenzwert := LREAL_TO_INT(fDrehmomentGrenzwert);

// Warten bis Istwert gesetzt wurde
IF arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_gesetz THEN
    arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := FALSE;
    bAchseInitialisiert := TRUE;
    Q_strStep := 'Achse initialisiert';
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="MonitorTorque" Id="{ffffffff-1111-2222-3333-444444444444}">
      <Declaration><![CDATA[METHOD MonitorTorque
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Drehmoment-Mittelwertbildung für stabilere Messung
arrDrehmomentIst[0] := ABS(fDrehmomentIst);
FOR idx := 10 TO 1 BY -1 DO
    arrDrehmomentIst[idx] := arrDrehmomentIst[idx-1];
END_FOR

// Mittelwert berechnen
fDrehmomentIstMittel := 0;
FOR idx := 0 TO 10 DO
    fDrehmomentIstMittel := fDrehmomentIstMittel + arrDrehmomentIst[idx];
END_FOR
fDrehmomentIstMittel := fDrehmomentIstMittel / 11;

// Tiefenänderung überwachen
fTiefenAenderung := ABS(fSchraubTiefeIst - fLetzteTiefe);

// Überwachung des Drehmoments
IF fDrehmomentIstMittel >= fMaxTorque THEN
    Q_bError := TRUE;
    Q_nErrorId := 65; // Drehmoment zu hoch
    Q_nStep := -1;
ELSIF fSchraubTiefeIst >= fSchraubTiefeSoll AND 
      fDrehmomentIstMittel < (fDrehmomentGrenzwert / 2) THEN
    // Solltiefe erreicht aber Drehmoment viel zu niedrig
    Q_bError := TRUE;
    Q_nErrorId := 2; // Drehmoment zu niedrig
    Q_nStep := -1;
END_IF

// Überwachung auf Überschreitung der Solltiefe
IF fSchraubTiefeIst < (fSchraubTiefeSoll - I_fTiefentoleranzPos - 2.0) THEN
    Q_bError := TRUE;
    Q_nErrorId := 61; // Solltiefe überschritten
    Q_nStep := -1;
END_IF

fLetzteTiefe := fSchraubTiefeIst;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadAxisValues" Id="{11111111-2222-3333-4444-555555555556}">
      <Declaration><![CDATA[METHOD ReadAxisValues
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Achsen-Istwerte aus NC lesen
fSchraubTiefeIst := arrNcAchsen[I_nEncId].fPosIstwert;
fDrehmomentIst := arrNcAchsen[I_nAchsId].stEinAusG.I_nDrehmomentIstwert;
fDrehzahlIst := arrNcAchsen[I_nAchsId].fVeloIstwert;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReduceSpeed" Id="{22222222-3333-4444-5555-666666666667}">
      <Declaration><![CDATA[METHOD ReduceSpeed
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Geschwindigkeit auf Anzugsgeschwindigkeit reduzieren
IF fSchraubTiefeIst >= (fSchraubTiefeSoll - fTiefeDrehzahlRed) THEN
    arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := fReducedSpeed;
    Q_strStep := 'Reduziere Drehzahl für Endposition';
ELSE
    arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fParam_Solldrehzahl;
END_IF

// BufferMode für sanften Übergang
arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode := MC_BlendingNext;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReferenceAxis" Id="{33333333-4444-5555-6666-777777777778}">
      <Declaration><![CDATA[METHOD ReferenceAxis
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Antriebsgeführtes Referenzieren
arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.2 := TRUE;

// Warten auf Rückmeldung
IF arrNcAchsen[I_nAchsId].stEinAusG.I_nSignalstatuswort.0 THEN
    arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.2 := FALSE;
    Q_strStep := 'Referenzierung abgeschlossen';
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAxis" Id="{44444444-5555-6666-7777-888888888889}">
      <Declaration><![CDATA[METHOD ResetAxis
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// NC-Achse zurücksetzen
arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.0 := TRUE; // Regler-Reset
arrNcAchsen[I_nAchsId].stGrdfkt.bReset_ausf := TRUE;

// Achse stoppen
arrStartAusf[I_nAchsId].I_bAchseStopPos := FALSE;
arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;

// Nach kurzer Zeit Reset zurücknehmen
tonStillstand(IN:=TRUE, PT:=T#100MS);
IF tonStillstand.Q THEN
    arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.0 := FALSE;
    arrNcAchsen[I_nAchsId].stGrdfkt.bReset_ausf := FALSE;
    tonStillstand(IN:=FALSE);
END_IF

Q_bAxisReset := arrNcAchsen[I_nAchsId].stGrdfkt.bReset_ausf;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetOutputs" Id="{55555555-6666-7777-8888-999999999990}">
      <Declaration><![CDATA[METHOD ResetOutputs
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Reset aller Ausgänge
Q_bBusy := FALSE;
Q_bDone := FALSE;
Q_bError := FALSE;
Q_bSchraubHub := FALSE;
Q_bSchrAuswurf := FALSE;
Q_bSchrHalt := FALSE;
Q_bDrehmomentFehler := FALSE;
Q_bAxisReset := FALSE;
Q_nErrorId := 0;
Q_sPosZustand := '';
Q_strStep := 'Bereit';

// Reset interner Variablen
bDrehmomentErreicht := FALSE;
bTiefenAenderungOK := FALSE;
bAchseInitialisiert := FALSE;
nFehlerCounter := 0;
nSchraubFall := 0;
fLetzteTiefe := 0.0;
fTiefenAenderung := 0.0;
fDrehmomentIstMittel := 0;

// Timer zurücksetzen
tonRampe(IN:=FALSE);
tonUeberwachung(IN:=FALSE);
tonStillstand(IN:=FALSE);
tonGeschwindigkeit(IN:=FALSE);

// Arrays zurücksetzen
FOR idx := 0 TO 10 DO
    arrDrehmomentIst[idx] := 0;
END_FOR

// Achse zurücksetzen wenn nötig
IF arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 THEN
    arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReturnToHome" Id="{66666666-7777-8888-9999-aaaaaaaaaaab}">
      <Declaration><![CDATA[METHOD ReturnToHome
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Zurück in Grundstellung
Q_bSchraubHub := FALSE;
Q_bSchrAuswurf := FALSE;
Q_bGrundstellungAktiv := TRUE;

// Achse in Grundstellung fahren (optional, abhängig von Mechanik)
IF NOT I_bGrdstlgSchrEinh THEN
    // Hier könnte eine Fahrt zur Grundstellung implementiert werden
    // z.B. arrNcAchsen[I_nAchsId].stAuftrg.fPTP_ZielPos := 0;
    Q_strStep := 'Fahre zur Grundstellung';
ELSE
    Q_bGrundstellungAktiv := FALSE;
    Q_strStep := 'Grundstellung erreicht';
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StartSpeedRamp" Id="{77777777-8888-9999-aaaa-bbbbbbbbbbbc}">
      <Declaration><![CDATA[METHOD StartSpeedRamp
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Drehzahlrampe starten
tonRampe(IN:=TRUE, PT:=tRampeHoch);

// Geschwindigkeit setzen
arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fStartDrehzahl;
arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode := MC_Aborting;

// Achse starten
arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;

// Lineare Rampe von Startdrehzahl auf Maximaldrehzahl
IF tonRampe.ET < tRampeHoch THEN
    fDrehzahlSoll := I_stParam.fStartDrehzahl + 
                     (I_stParam.fParam_Solldrehzahl - I_stParam.fStartDrehzahl) * 
                     TIME_TO_REAL(tonRampe.ET) / TIME_TO_REAL(tRampeHoch);
    arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := fDrehzahlSoll;
ELSE
    arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fParam_Solldrehzahl;
    tonRampe(IN:=FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StopAxis" Id="{88888888-9999-aaaa-bbbb-cccccccccccd}">
      <Declaration><![CDATA[METHOD StopAxis
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Achse kontrolliert stoppen
arrStartAusf[I_nAchsId].I_bAchseStopPos := TRUE;
arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;

// Drehmomentgrenzwert auf 0 setzen
arrNcAchsen[I_nAchsId].stEinAusG.Q_nDrehmomentGrenzwert := 0;

// Warten auf Rückmeldung
IF arrStartAusf[I_nAchsId].Q_bAchseGestPos OR 
   arrStartAusf[I_nAchsId].Q_bAchseInPos OR
   arrNcAchsen[I_nAchsId].stStatus.bInStillst THEN
    Q_strStep := 'Achse gestoppt';
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateErrorMessages" Id="{99999999-aaaa-bbbb-cccc-ddddddddddde}">
      <Declaration><![CDATA[METHOD UpdateErrorMessages
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Meldungsstruktur aktualisieren
IQ_stMeldung.bMeldFehlNachladen := (Q_nErrorId = 40);
IQ_stMeldung.bMeldFehlLangsameGeschwindigkeit := (Q_nErrorId = 45);
IQ_stMeldung.bMeldFehlTiefeSolldrehzahl := FALSE; // Nicht mehr verwendet
IQ_stMeldung.bMeldFehlSollTiefe := (Q_nErrorId = 60);
IQ_stMeldung.bMeldFehlSollTiefeUebers := (Q_nErrorId = 61);
IQ_stMeldung.bMeldFehlSollDrehmom := (Q_nErrorId = 2) OR (Q_nErrorId = 65);
IQ_stMeldung.bMeldFehlSchrauberstange := (Q_nErrorId = 80);
IQ_stMeldung.bMeldFehlAuswerfen := FALSE; // Auswerflogik nicht implementiert

IQ_stMeldung.sName := 'Servoschrauber';
IQ_stMeldung.SourceName := 'FB_Schrauber_PnP_Neu';]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Schrauber_PnP_Neu_1">
      <LineId Id="3" Count="8" />
      <LineId Id="511" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="512" Count="0" />
      <LineId Id="514" Count="0" />
      <LineId Id="513" Count="0" />
      <LineId Id="515" Count="0" />
      <LineId Id="13" Count="14" />
      <LineId Id="349" Count="0" />
      <LineId Id="28" Count="157" />
      <LineId Id="509" Count="0" />
      <LineId Id="186" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.CheckAxisErrors">
      <LineId Id="3" Count="20" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.CheckFinalPosition">
      <LineId Id="3" Count="5" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.CheckFinishConditions">
      <LineId Id="3" Count="10" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.CheckSpeedReached">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.CheckStartConditions">
      <LineId Id="3" Count="18" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.DetermineSchraubfall">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ExecuteMainScrewing">
      <LineId Id="3" Count="19" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ExecuteTiefenPruefung">
      <LineId Id="3" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.HandleCase1">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.HandleCase2">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.HandleCase3">
      <LineId Id="3" Count="17" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.HandleCase4">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.HandleError">
      <LineId Id="3" Count="48" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.InitializeAxis">
      <LineId Id="3" Count="17" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.MonitorTorque">
      <LineId Id="3" Count="35" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ReadAxisValues">
      <LineId Id="3" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ReduceSpeed">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ReferenceAxis">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ResetAxis">
      <LineId Id="3" Count="15" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ResetOutputs">
      <LineId Id="3" Count="36" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.ReturnToHome">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.StartSpeedRamp">
      <LineId Id="3" Count="18" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.StopAxis">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_Neu_1.UpdateErrorMessages">
      <LineId Id="3" Count="10" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>