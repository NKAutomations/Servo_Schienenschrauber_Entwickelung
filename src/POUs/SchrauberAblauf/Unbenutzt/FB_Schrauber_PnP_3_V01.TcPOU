<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_Schrauber_PnP_3_V01" Id="{8136173d-387c-4427-bb7e-28078ae13d0d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Schrauber_PnP_3_V01
(*	Abgeändert vom Original Ablauf
	Händisch angepasste Version, Mit Chat GPT5 in Methoden Unterteilt.
	
================================================================================
SERVOSCHRAUBER PICK-AND-PLACE - MÖBELINDUSTRIE
================================================================================
Beschreibung:	Vollautomatischer Servoschrauber für Schienen- und Einzelschrauben
				mit NC-Achsenanbindung, Drehmoment- und Tiefenüberwachung
				
Autor:			Überarbeitet für bessere Wartbarkeit und Übersichtlichkeit
Datum:			September 2025
Version:		0.1
				
				Drehwinkelüberwachung!

ABLAUFBESCHREIBUNG:
===================
1. INITIALISIERUNG		(Step 0)    - Reset aller Ausgänge, Grundzustand
2. BEREITSCHAFT			(Step 10)   - Warten auf Startbedingungen
3. NACHLADEN			(Step 11-12)- Schraube aus Schlauch nachladen
4. SCHRAUBSTART			(Step 20)   - Vorbereitung Schraubvorgang
5. ZUSTELLUNG			(Step 30)   - Schraubhub ausfahren
6. AUFSETZEN			(Step 40)   - Auswurfhub bis Werkstück
7. ANLAUFPHASE			(Step 45)   - Langsame Drehzahl aufbauen
8. HAUPTSCHRAUBEN		(Step 50)   - Volldrehzahl erreichen
9. TIEFENPRÜFUNG		(Step 60)   - Solltiefe überwachen
10. DREHMOMENTPRÜFUNG	(Step 65)   - Sollmoment erreichen
11. MOTORSTOPP			(Step 70-75)- Kontrolliertes Stoppen
12. RÜCKFAHRT			(Step 80-85)- Zurück in Grundstellung
13. REFERENZIERUNG		(Step 90-95)- Achse referenzieren
14. ABSCHLUSS			(Step 100)  - Vorgang beendet
15. AUSWERFEN			(Step 200ff)- Schraube entfernen
16. FEHLERBEHANDLUNG	(Step -xx)  - Zentrale Fehlerbehandlung

SICHERHEITSFUNKTIONEN:
======================
- Watchdog-Timer für alle kritischen Schritte
- Überwachung von Schutzbereich und NC-Status
- Drehmomentbegrenzung und -überwachung
- Tiefentoleranzprüfung
- Automatische Fehlerquittierung (optional)
- Deterministische Zustandsmaschine
================================================================================
*)

VAR_INPUT
	(* === STEUERUNGSEINGÄNGE === *)
	I_bResetTeststation				: BOOL;		(* Test-Reset für Steuerungstechniker-Büro *)
	I_bTaktFrg						: BOOL;		(* Taktfreigabe vom übergeordneten System *)
	I_bTaktStop						: BOOL;		(* Taktstopp - stoppt aktuellen Vorgang *)
	I_bAuto							: BOOL;		(* Automatikbetrieb aktiv *)
	I_bHand							: BOOL;		(* Handbetrieb aktiv *)
	I_bQuittFehler					: BOOL;		(* Manuelle Fehlerquittierung *)
	I_bGrundstellung				: BOOL;		(* Anfahrt Grundstellung angefordert *)
	I_bSchutzbereichOK				: BOOL;		(* Schutzbereich ist frei *)

	(* === BESCHREIBUNGEN FÜR MELDUNGEN === *)
	I_sSourceBeschreibung			: STRING;	(* Quelle für Fehlermeldungen *)
	I_sPosBeschreibung				: STRING := 'Schrauber';	(* Positionsbeschreibung *)

	(* === PROZESSEINGÄNGE === *)
	I_bTaktStart					: BOOL;		(* Start für Vollschraubung (Schienenschrauben) *)
	I_bTaktStartHalb				: BOOL;		(* Start für Halbschraubung (z.B. Metalltraverse) *)
	I_bGrdstlgSchrEinh				: BOOL;		(* Schraubeinheit in Grundstellung *)
	I_bZustellZylAusgef				: BOOL;		(* Zustellzylinder ausgefahren (Endlage) *)

	(* === PROZESSPARAMETER === *)
	I_fSchraubTiefeAuswurf			: LREAL;	(* Auswurftiefe für Schraubenentfernung [mm] *)
	I_fTiefentoleranzPositiv		: LREAL := 1.0;		(* Positive Tiefentoleranz [mm] *)
	I_fTiefentoleranzNegativ		: LREAL := 0.5;		(* Negative Tiefentoleranz [mm] *)
	
	(* === ACHSENKONFIGURATION === *)
	I_nAchsId						: INT;		(* NC-Achsen-ID für Schraubmotor *)
	I_nEncId						: INT;		(* Encoder-ID für Tiefenmessung *)
	I_stParam						: ST_ParamSKSServoschrauber;	(* Prozessparameter *)

	(* === ERWEITERTE FUNKTIONEN === *)
	I_tAutoQuit						: TIME := T#0MS;	(* Automatische Quittierzeit (T#0MS = deaktiviert) *)
	I_bSchraubeNachschiessen		: BOOL;		(* Nachschießfunktion aktiv *)
	I_bReferenzfahrtAktiv			: BOOL;		(* Referenzfahrt läuft gerade *)
	I_bFreigabeAuswerfen			: BOOL;		(* Freigabe für Auswurfvorgang *)
	
	(* === LOGGING UND DIAGNOSE === *)
	I_sDateipfad					: STRING;	(* Pfad für Logdateien *)
	I_bSchrauberLogOn				: BOOL;		(* Schrauber-Abwahl (Log-Modus) *)
	I_nMotorHersteller				: INT;		(* 0=BRC, 1=Beckhoff *)
	I_bHuettenSchr					: BOOL := FALSE;	(* Hüttenhölscher/Boellhoff-Schrauber *)

END_VAR

VAR_OUTPUT
	(* === HAUPTAUSGÄNGE === *)
	Q_bBusy							: BOOL;		(* Schrauber arbeitet gerade *)
	Q_bDone							: BOOL;		(* Schraubvorgang erfolgreich beendet *)
	Q_bError						: BOOL;		(* Fehler aufgetreten *)

	(* === STATUSINFORMATIONEN === *)
	Q_sPosZustand					: STRING := '';		(* Aktueller Positionszustand *)
	Q_bGrundstellungAktiv			: BOOL;		(* Grundstellungsfahrt aktiv *)
	Q_bGrundstellungOk				: BOOL;		(* Grundstellung erreicht *)
	Q_sStatus						: STRING(255);		(* Detaillierte Statusmeldung *)

	(* === AKTORAUSGÄNGE === *)
	Q_bSchraubHub					: BOOL;		(* Schraubhub ausfahren *)
	Q_bSchrAuswurf					: BOOL;		(* Auswurfhub ausfahren *)
	Q_bSchrHalt						: BOOL;		(* Motor stoppen *)
	Q_nTorque						: INT := 300;		(* Drehmomentgrenzwert [0.1%] *)
	Q_bAxisReset					: BOOL;		(* Achse zurücksetzen *)

	(* === DIAGNOSEINFORMATIONEN === *)
	Q_nErrorId						: INT;		(* Eindeutige Fehler-ID *)
	Q_bDrehmomentFehler				: BOOL;		(* Drehmomentfehler aufgetreten *)
	Q_bTuerFreigabe					: BOOL;		(* Türfreigabe für Schutzeinrichtung *)
	Q_nStep							: INT;		(* Aktuelle Schrittnummer *)
	Q_strStep						: STRING;	(* Aktuelle Schrittbezeichnung *)
	Q_bModuloBetrArt				: BOOL;		(* Modulo-Betriebsart aktiv *)

END_VAR

VAR_IN_OUT
	(* === SCHNITTSTELLEN ZU ANDEREN BAUSTEINEN === *)
	IQ_fbObjSchlauch				: FB_Obj_IOSchlauch;		(* Schlauchsystem-Interface *)
	IQ_stMeldung					: ST_MeldServoSchrauber_1;	(* Meldungsstruktur *)
END_VAR
VAR
	(* === FEHLERVERWALTUNG === *)
	objError_Schrauber				: FB_Obj_Error_Schrauber;	(* Zentrale Fehlerverwaltung *)

	(* === INTERNE STEUERUNGSFLAGS === *)
	bSchrAuswurfStart				: BOOL;		(* Auswurfstart intern *)
	bSchraubHub						: BOOL;		(* Schraubhub intern *)
	bSchrAuswurf					: BOOL;		(* Auswurf intern *)
	bModuloBetrArt					: BOOL;		(* Modulo-Betrieb intern *)
	bReset							: BOOL;		(* Reset-Signal intern *)
	bAchsreset						: BOOL;		(* Achsen-Reset intern *)

	(* === PROZESSWERTE === *)
	fSchraubTiefeIst				: LREAL;	(* Aktuelle Schraubtiefe [mm] *)
	fDrehmomentIstMittel			: LREAL;	(* Gemitteltes Drehmoment [0.1%] *)
	nTiefeBeimAufsetzen				: LREAL;	(* Tiefe beim ersten Werkstückkontakt *)
	bTiefeBeimAufsetzenOK			: BOOL;		(* Aufsetzen korrekt erkannt *)
	bTiefeOkMem						: BOOL;
	bDrehmomOkMem					: BOOL;
	bDrehwinkelOkMem				: BOOL;
	nDrehwinkelMem					: LREAL ;
	
	(* === DREHMOMENT-MITTELWERTBILDUNG === *)
	arrDrehmomentIst				: ARRAY [0..10] OF LREAL;	(* Ringpuffer für Drehmoment *)
	idx								: INT;		(* Index für Array-Verarbeitung *)

	(* === TIMER UND ÜBERWACHUNG === *)
	tonAnlauf						: TON;		(* Anlauftimer *)
	tonStillstandAchse				: TON;		(* Achsen-Stillstandsüberwachung *)
	tonStillstandVorschub			: TON;		(* Vorschub-Stillstandsüberwachung *)
	tonStillstVorschubDelay			: TON;		(* Verzögerung Stillstandsüberwachung *)
	tonVerzStillstand				: TON;		(* Verzögerter Stillstand *)
	tonTimeOutSchrauber				: TON;		(* Watchdog Schraubvorgang *)
	tonAutoquit						: TON;		(* Timer für automatische Quittierung *)
	tonTimeOver1					: TON;		(* Universeller Timeout-Timer 1 *)
	tonDelay1						: TON;		(* Universeller Verzögerungstimer *)
	tonNotPosiFrg					: TON;		(* Timer für Positionierfreigabe *)
	tonSchraubtakt					: TON;		(* Timer für Schraubtakt-Messung *)

	(* === FEHLERBEHANDLUNG === *)
	nFehlerSchrittMerker			: INT;		(* Merker für Fehlerschritt *)
	nFehlerZaehler					: INT;		(* Zähler für aufgetretene Fehler *)

	(* === TRIGGER UND FLANKENAUSWERTUNG === *)
	rtrigReset						: R_TRIG;	(* Reset-Flanke *)
	ftrigStep60						: F_TRIG;	(* Fallende Flanke Step 60 *)
	rtrigStep70						: R_TRIG;	(* Steigende Flanke Step 70 *)
	ftrigStep70						: F_TRIG;	(* Fallende Flanke Step 70 *)
	rtrigStepError					: R_TRIG;	(* Steigende Flanke Fehler *)

	(* === AUTO-QUIT FUNKTIONALITÄT === *)
	bAutoquitAktiv					: BOOL;		(* Auto-Quit ist aktiv *)

	(* === ZUSTANDSMASCHINE === *)
	nStep							: INT;		(* Aktuelle Schrittnummer *)
	sStep							: STRING;	(* Aktuelle Schrittbezeichnung *)
	nOldStep						: INT;		(* Vorherige Schrittnummer *)
	tonTimeOverGrund				: TON;		(* Timeout Grundstellung *)

	(* === DIAGNOSE UND LOGGING === *)
	fbStepHistory					: FB_StepHistory;			(* Schritthistorie *)
	fbLogToFile						: FB_LogFile_Schrauber;	(* Datei-Logging *)
	
	(* === STATISTISCHE AUSWERTUNG === *)
	timeSchraubtakt					: TIME;		(* Gemessene Schraubtaktzeit *)
	arrLetzteTiefe					: ARRAY[0..100] OF LREAL;	(* Historie Schraubtiefen *)
	arrLetzteFehler					: ARRAY[0..100] OF LREAL;	(* Historie Fehlercodes *)
	arrLetzteMomente				: ARRAY[0..100] OF LREAL;	(* Historie Drehmomente *)
	arrLetzteSchraubzeit			: ARRAY[0..100] OF TIME;	(* Historie Schraubzeiten *)
	rtrigStueckzaehler				: R_TRIG;	(* Trigger Stückzähler *)
	nStueckzaehler					: INT;		(* Stückzähler *)
	rtrigSchrauberfehler			: R_TRIG;	(* Trigger Schrauberfehler *)

	(* === SonderZähler === *)
	nAnzahlSchraubspitzenKlemmer	: DINT;		(* Zähler für Schraubspitzenklemmer *)
	
	(* === Drehmoment Parameter === *)
	nDrehmomentKonstante			: LREAL	:= 0.2; (*0x8011:16	*)
	nNennleistungMotor				: LREAL	:= 4;	(*0x8011:12	*)
	nDrehmomentSkalierVorgabe		: LREAL := 1.1;	(* 10% Mehr Drehmoment als das Solldrehmoment *)
	nSollDrehmomentErrechnet		: LREAL;		(* Der errechnete Drehmomentwert, Rechnet Drehmoment (Nm) um in Prozessdaten kompatibelen wert für den Antrieb! *)
	
	(* === Tiefen Parameter === *)
	nMinimalAufsetztiefe			: LREAL := 10;	(* MinimalTiefe für Aufsetzen OK *)
	nMinimalAufsetztiefeToleranz	: LREAL := 5;	(* MinimalTiefe Toleranz für Aufsetzen OK *)
	
	nMinimalSchraubtiefe			: LREAL := -10;
	nMinimalSchraubtiefeHalb		: LREAL := 10;
	
	(* === Drehwinkelprüfung Parameter === *)
	nSollDrehwinkelNachTiefeOK		: LREAL := 60;
	nMaxDrehwinkelNachTiefeOk		: LREAL := 900;	
	
	(* === DrehzahlReduktions Parameter === *)
	nSkalDrehzReduzTiefeOk			: LREAL := 0.12; 	(* Drehzahl Reduzierungsskalierung bei Tiefe OK  um genau weiter zu Positionieren*)
	nSkalDrehzReduzHalb				: LREAL := 0.5;		(* Drehzahlreduzierung für Halbschraubung *)
	
	(* === Prozesswerte für Analyse === *)
	nPD_Tiefe						: LREAL;	(* Prozessdaten - erreichte Tiefe *)
	nPD_Drehmoment					: LREAL;
	nPD_Drehwinkel					: LREAL;
	
	(* === Merker für Umdrehungen === *)
	nPosMerkerTiefeOk				: LREAL;
	
	(* === Achsanschaltung === *)
	NC_Axis_OUT_bSteuerwortBit1			:BOOL;
	NC_Axis_OUT_bSteuerwortBit2			:BOOL;
	
	NC_Axis_OUT_bIstwertSetzen			:BOOL;
	NC_Axis_OUT_bAchsePosStarten		:BOOL;
	NC_Axis_OUT_nPosIstwertSetzen		:LREAL;
	NC_Axis_OUT_nPTPVelo				:LREAL;
	NC_Axis_OUT_PTPBuffMode				:MC_BufferMode;
	
	NC_Axis_IN_bDCStatuswort13			:BOOL;
	NC_Axis_IN_bStatuswortBit0			:BOOL;
	NC_Axis_IN_bIstWertgesetzt			:BOOL;
	NC_Axis_IN_bPTPPosiFreig			:BOOL;
	NC_Axis_IN_bNcFehler				:BOOL;
	NC_Axis_IN_nActPos					:LREAL;
	NC_Axis_IN_nActVelo					:LREAL;
	NC_Axis_IN_nParamEilgeschw			:LREAL;
	NC_Axis_IN_nActTorque				:INT;
	
	NC_Axis_IN_bFaehrtPos				:BOOL;
	NC_Axis_IN_bInPos					:BOOL;
	NC_Axis_IN_bInStillstand			:BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
================================================================================
HAUPTPROGRAMM SERVOSCHRAUBER
================================================================================
Aufruffolge der Methoden:
1. Reset-Behandlung
2. Hauptablauf (Zustandsmaschine)
3. Fehlerbehandlung
4. Logging und Diagnose
5. Ausgangszuweisung
================================================================================
*)

// === RESET-BEHANDLUNG ===
m_HandleReset();

// === HAUPTABLAUF (ZUSTANDSMASCHINE) ===
m_Hauptablauf();

// === DREHMOMENT-MITTELWERTBILDUNG ===
m_DrehmomentMittelwert();

// === SCHRAUBTAKT-ZEITMESSUNG ===
m_SchraubtaktMessung();

// === DIAGNOSE-HISTORIE ===
m_DiagnoseHistorie();

// === STILLSTANDS-ÜBERWACHUNG ===
m_StillstandsUeberwachung();

// === Achs Kommunikation ===
m_AchsKommunikation();

// === FEHLERBEHANDLUNG ===
m_Fehlerbehandlung();

// === LOGGING UND DIAGNOSE ===
m_LoggingUndDiagnose();

// === AUSGANGSZUWEISUNG ===
m_Ausgangszuweisung();


]]></ST>
    </Implementation>
    <Method Name="m_AchsKommunikation" Id="{0a382c48-8b70-4d0d-9a4a-6bcb3034a39d}">
      <Declaration><![CDATA[METHOD m_AchsKommunikation
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 	:=	NC_Axis_OUT_bSteuerwortBit1;
arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.2	:=	NC_Axis_OUT_bSteuerwortBit2;
													
arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz			:=	NC_Axis_OUT_bIstwertSetzen;
arrStartAusf[I_nAchsId].I_bAchseZurArbP				:=	NC_Axis_OUT_bAchsePosStarten;
arrNcAchsen[I_nAchsId].stGrdfkt.fIstSetzwert		:=	NC_Axis_OUT_nPosIstwertSetzen;
arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw			:=	NC_Axis_OUT_nPTPVelo;
arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode		:=	NC_Axis_OUT_PTPBuffMode	;


NC_Axis_IN_bDCStatuswort13			:=	arrNcAchsen[I_nAchsId].stEinAusG.I_nDCStatusword.13;
NC_Axis_IN_bStatuswortBit0			:=	arrNcAchsen[I_nAchsId].stEinAusG.I_nSignalstatuswort.0;
NC_Axis_IN_bIstWertgesetzt			:=	arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_gesetz;
NC_Axis_IN_bPTPPosiFreig			:=	arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg;
NC_Axis_IN_bNcFehler				:=	arrNcAchsen[I_nAchsId].bNcFehler;

NC_Axis_IN_nActPos					:=	arrNcAchsen[I_nAchsId].fPosIstwert;
NC_Axis_IN_nActVelo					:=	arrNcAchsen[I_nAchsId].fVeloIstwert ;
NC_Axis_IN_nParamEilgeschw			:=	arrNcAchsen[I_nAchsId].stParam.fEilgGeschw;
NC_Axis_IN_bFaehrtPos				:=	arrNcAchsen[I_nAchsId].stStatus.bFaehrtPos;

NC_Axis_IN_bInPos					:=	arrStartAusf[I_nAchsId].Q_bAchseGestPos
										OR arrStartAusf[I_nAchsId].Q_bAchseInPos;
										
NC_Axis_IN_bInStillstand			:=	arrNcAchsen[I_nAchsId].stStatus.bInStillst;
NC_Axis_IN_nActTorque				:=	ABS(arrNcAchsen[I_nAchsId].stEinAusG.I_nDrehmomentIstwert);]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Ausgangszuweisung" Id="{e1f2cfb5-fd57-4075-856e-fa455e2bc2e9}">
      <Declaration><![CDATA[METHOD m_Ausgangszuweisung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
AUSGANGSZUWEISUNG
================================================================================
Zentrale Zuweisung aller Ausgangssignale mit Sicherheitsverriegelung
durch Schutzbereich und Reset-Zustand
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === SCHLAUCHSYSTEM-STEUERUNG ===
IQ_fbObjSchlauch.I_bSotiertopfEin := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND (nStep = 11 
	OR nStep = 21);

IQ_fbObjSchlauch.I_bFrgNachladen := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND (nStep = 11);

// === PNEUMATIK-AUSGÄNGE ===
Q_bSchraubHub := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND bSchraubHub;

Q_bSchrAuswurf := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND bSchrAuswurf;

// === HAUPTSTATUS-AUSGÄNGE ===
Q_bBusy		:= (nStep <> 10);		(* Beschäftigt wenn nicht in Bereitschaft *)
Q_bDone		:= (nStep = 100);		(* Fertig bei Schritt 100 *)
Q_bSchrHalt	:= (nStep = 70);		(* Motor-Halt bei Schritt 70 *)

// === ACHSEN-STEUERUNG ===
Q_bAxisReset := bAchsreset;

// === SICHERHEITS-AUSGÄNGE ===
Q_bTuerFreigabe := (nStep <= 10);	(* Türfreigabe nur in Grundzustand *)

// === DIAGNOSE-AUSGÄNGE ===
Q_nStep 	:= nStep;
Q_strStep	:= sStep;
Q_sStatus	:= CONCAT(INT_TO_STRING(nStep), CONCAT(' - ', sStep));

// === MODULO-BETRIEBSART ===
Q_bModuloBetrArt := bModuloBetrArt;]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DiagnoseHistorie" Id="{311d60a6-8abd-441e-988c-fec7a7198c10}">
      <Declaration><![CDATA[METHOD m_DiagnoseHistorie : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
DIAGNOSE-HISTORIE
================================================================================
Speichert die letzten 100 Schraubvorgänge mit allen wichtigen Parametern
für Qualitätssicherung und Fehleranalyse.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === FLANKENAUSWERTUNG FÜR SCHRAUBENDE ===
ftrigStep70(CLK := nStep = 70);
rtrigStep70(CLK := nStep = 70);

// === DATEN IN HISTORIE SPEICHERN ===
IF rtrigStep70.Q 
THEN
	// Alle Arrays nach rechts verschieben
	FOR idx := 100 TO 1 BY -1 DO
		arrLetzteTiefe[idx] 		:= arrLetzteTiefe[idx-1];
		arrLetzteFehler[idx] 		:= arrLetzteFehler[idx-1];
		arrLetzteMomente[idx] 		:= arrLetzteMomente[idx-1];
		arrLetzteSchraubzeit[idx] 	:= arrLetzteSchraubzeit[idx-1];
	END_FOR
	
	// Aktuelle Werte speichern
	arrLetzteTiefe[0] 		:= fSchraubTiefeIst;
	arrLetzteFehler[0] 		:= nFehlerSchrittMerker;
	arrLetzteMomente[0] 	:= fDrehmomentIstMittel;
	arrLetzteSchraubzeit[0] := timeSchraubtakt;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentMittelwert" Id="{50ebf64a-72c1-4e32-851c-0f7107708692}">
      <Declaration><![CDATA[METHOD m_DrehmomentMittelwert : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
DREHMOMENT-MITTELWERTBILDUNG
================================================================================
Berechnet den gleitenden Mittelwert des Drehmoments über 10 Werte
zur Vermeidung von Fehlauslösungen durch kurze Spitzen.
================================================================================
*)
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === MITTELWERTBILDUNG NUR WÄHREND DREHMOMENTPRÜFUNG ===
IF nStep >= 62 
	AND nStep <= 70 
THEN
	m_DrehmomentRechnung(
		nTorqueActValue:= 		INT_TO_LREAL(NC_Axis_IN_nActTorque), 
		nRatedCurrentMotor:=	nNennleistungMotor , 	
		nTorqueConstant:= 		nDrehmomentKonstante, 
		nActTorqueCalc=> 		arrDrehmomentIst[0]);
	
	// Array nach rechts verschieben (Ringpuffer)
	FOR idx := 10 TO 1 BY -1 DO
		arrDrehmomentIst[idx] := arrDrehmomentIst[idx-1];
	END_FOR
	
	// Mittelwert über alle 10 Werte berechnen
	fDrehmomentIstMittel := (arrDrehmomentIst[1] 
						   + arrDrehmomentIst[2] 
						   + arrDrehmomentIst[3] 
						   + arrDrehmomentIst[4] 
						   + arrDrehmomentIst[5] 
						   + arrDrehmomentIst[6] 
						   + arrDrehmomentIst[7] 
						   + arrDrehmomentIst[8] 
						   + arrDrehmomentIst[9] 
						   + arrDrehmomentIst[10]) / 10;
ELSE
	fDrehmomentIstMittel := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentPruefung" Id="{80bde221-5071-4d09-9798-a43ee62b6b2a}">
      <Declaration><![CDATA[METHOD m_DrehmomentPruefung : BOOL
VAR_INPUT
	nDrehmomentSoll		:LREAL;				
END_VAR
VAR_OUTPUT
	bDrehmomentOk		:BOOL;
END_VAR
(*
================================================================================
DrehmomentPruefung
================================================================================
Berechnet den gleitenden Mittelwert des Drehmoments über 10 Werte
zur Vermeidung von Fehlauslösungen durch kurze Spitzen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fDrehmomentIstMittel >= 
	nDrehmomentSoll
   AND (I_bTaktStart 
	   OR I_bTaktStartHalb)
THEN
	bDrehmomentOk := TRUE;	(* -> Drehmoment erreicht *)
ELSE
	bDrehmomentOk := FALSE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentRechnung" Id="{e1c5dea6-d536-46dd-8a93-1d9e665d56d8}">
      <Declaration><![CDATA[METHOD m_DrehmomentRechnung : BOOL
VAR_INPUT
	
	
	nTorqueActValue		:LREAL;	
	
	nRatedCurrentMotor	:LREAL;	(*0x8011:12	*)
	nTorqueConstant		:LREAL;	(*0x8011:16	*)
END_VAR
VAR_OUTPUT
	nActTorqueCalc		:LREAL;
END_VAR
(*Achtung dies aus der Original Beckhoff Doku:

Anzeige des aktuellen Drehmomentwertes
Der Wert wird in 1000stel vom rated current (0x8011:12
[} 151]) angegeben
Formel für Index 0x8010:54 [} 148] = 0 :
M = ((Torque actual value / 1000) x (rated current /
√2)) x torque constant (0x8011:16 [} 151])
Formel für Index 0x8010:54 [} 148] = 1 :
M = ((Torque actual value / 1000) x rated current)) x
torque constant (0x8011:16 [} 151])*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[nActTorqueCalc:=	
(((nTorqueActValue/1000) * (nRatedCurrentMotor / 1.4142))* nTorqueConstant);		(* Wurzel ziehen am besten einmalig bei Startup *)
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentVorgabe" Id="{0935f087-b115-4c5f-a56d-c133b045ea0c}">
      <Declaration><![CDATA[METHOD m_DrehmomentVorgabe : BOOL
VAR_INPUT
	nSkalierung			:LREAL;
	nTorque				:LREAL;		(* Eingang Soll Drehmoment in Nm	*)
	
	nRatedCurrentMotor	:LREAL;	(*0x8011:12	*)
	nTorqueConstant		:LREAL;	(*0x8011:16	*)
END_VAR
VAR_OUTPUT
	nTorqueLimitation	:LREAL;
END_VAR
(*Achtung dies aus der Original Beckhoff Doku:

Anzeige des aktuellen Drehmomentwertes
Der Wert wird in 1000stel vom rated current (0x8011:12
[} 151]) angegeben
Formel für Index 0x8010:54 [} 148] = 0 :
M = ((Torque actual value / 1000) x (rated current /
√2)) x torque constant (0x8011:16 [} 151])
Formel für Index 0x8010:54 [} 148] = 1 :
M = ((Torque actual value / 1000) x rated current)) x
torque constant (0x8011:16 [} 151])*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[nTorqueLimitation := ((nTorque / nTorqueConstant) / (nRatedCurrentMotor / 1.4142)) * 1000 *nSkalierung;]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehwinkelPruefung" Id="{61dbd554-2147-4592-aef8-bac8a5376247}">
      <Declaration><![CDATA[METHOD m_DrehwinkelPruefung : BOOL
VAR_INPUT
	nPosAct		:LREAL;	(* Aktuelle Position  *)
	nPosMem		:LREAL;	(* Gespeicherte Position *)
	nPosSoll	:LREAL; (* Soll Drehwinkel *)
	nMaxDrehwinkel	:LREAL;
	
END_VAR
VAR_OUTPUT
	bWinkelOk			:BOOL;
	nWinkelAct	:LREAL;
END_VAR
VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nWinkelAct :=	nPosAct-nPosMem;

bWinkelOk :=	nWinkelAct > nPosSoll 
				AND nWinkelAct < nMaxDrehwinkel;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Fehlerbehandlung" Id="{adc8884b-205f-4fd2-ab78-c7aa47c1b49f}">
      <Declaration><![CDATA[METHOD m_Fehlerbehandlung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
ZENTRALE FEHLERBEHANDLUNG
================================================================================
Verwaltet alle Fehlerzustände und erstellt entsprechende Meldungen.
Jeder Fehler hat eine eindeutige ID und eine klare Beschreibung.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === EINZELFEHLER-BEHANDLUNG ===

// Fehler -40: Schraube fehlt beim Nachladen
objError_Schrauber.I_fbFehlerNachladen(
	I_bAktiv := (nStep = -40));

// Fehler -45: Langsame Geschwindigkeit wird nicht erreicht
objError_Schrauber.I_fbFehlerLangsameGeschwindigkeit(
	I_bAktiv := (nStep = -45));

// Fehler -50: Schraubtiefe für Solldrehzahl wird nicht erreicht
objError_Schrauber.I_fbFehlerTiefeSolldrehzahl(
	I_bAktiv := (nStep = -50));

// Fehler -60: Solltiefe nicht erreicht
objError_Schrauber.I_fbFehler_Tiefe(
	I_bAktiv := (nStep = -60));

// Fehler -61: Solltiefe überschritten
objError_Schrauber.I_fbFehler_TiefeUeberschritten(
	I_bAktiv := (nStep = -61));

// Fehler -65: Solldrehmoment nicht erreicht
objError_Schrauber.I_fbFehler_Sollmoment(
	I_bAktiv := (nStep = -65));

// Fehler -80: Fehler beim Heben/Senken der Schrauberstange
objError_Schrauber.I_fbFehler_Schrauberstange(
	I_bAktiv := (nStep = -80));

// Fehler -210: Fehler beim Auswerfen
objError_Schrauber.I_fbFehlerAuswurf(
	I_bAktiv := (nStep = -210));

// === ALLGEMEINE FEHLERANZEIGE ===
Q_bError := (nStep < 0) AND NOT I_bSchrauberLogOn;

// === MELDUNGSSTRUKTUR AKTUALISIEREN ===
IQ_stMeldung.bMeldFehlNachladen 				:= objError_Schrauber.I_fbFehlerNachladen.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlLangsameGeschwindigkeit 	:= objError_Schrauber.I_fbFehlerLangsameGeschwindigkeit.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlTiefeSolldrehzahl 		:= objError_Schrauber.I_fbFehlerTiefeSolldrehzahl.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSollTiefe 				:= objError_Schrauber.I_fbFehler_Tiefe.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSollTiefeUebers 			:= objError_Schrauber.I_fbFehler_TiefeUeberschritten.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSollDrehmom 				:= objError_Schrauber.I_fbFehler_Sollmoment.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSchrauberstange 			:= objError_Schrauber.I_fbFehler_Schrauberstange.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlAuswerfen 				:= objError_Schrauber.I_fbFehlerAuswurf.I_bAktiv 
													AND NOT I_bSchrauberLogOn;

// === MELDUNGSIDENTIFIKATION ===
IQ_stMeldung.sName 		:= I_sPosBeschreibung;
IQ_stMeldung.SourceName := I_sSourceBeschreibung;]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_HandleReset" Id="{6dfaddf5-8f42-4220-ac8d-f5a56aa98d57}">
      <Declaration><![CDATA[METHOD m_HandleReset : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
RESET-BEHANDLUNG
================================================================================
Zentrale Behandlung aller Reset-Bedingungen.
Reset ist möglich über:
- Nachschüttel-Taste (wenn nicht in kritischen Schritten)
- Test-Reset für Steuerungstechniker
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === RESET-FLANKENAUSWERTUNG ===
rtrigReset(CLK := IQ_fbObjSchlauch.I_bTasteNachruetteln);

// === RESET-BEDINGUNGEN ===
bReset := rtrigReset.Q 
		AND NOT (nStep = 10 
		OR nStep = 90)	(* Nicht in kritischen Schritten *)
		OR I_bResetTeststation;				(* Test-Reset für Steuerungstechniker *)]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Hauptablauf" Id="{b90f892b-83a2-4f12-a4a5-a529a7e19a6a}">
      <Declaration><![CDATA[METHOD m_Hauptablauf : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
HAUPTABLAUF - ZUSTANDSMASCHINE SERVOSCHRAUBER
================================================================================
Zentrale Zustandsmaschine mit deterministischem Ablauf.
Alle Schritte sind eindeutig nummeriert und kommentiert.
Watchdog-Timer überwachen kritische Phasen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === HAUPTZUSTANDSMASCHINE ===
IF NOT bReset 
THEN
	CASE nStep OF
(*================================================================================================================*)	
	// ================================================================================
	// INITIALISIERUNG UND BEREITSCHAFT
	// ================================================================================
	
	0: (* === INITIALISIERUNG === *)
		sStep := 'Initialisierung';
		
		// Alle Ausgänge zurücksetzen
		bSchraubHub 		:= FALSE;
		bSchrAuswurf 		:= FALSE;
		bAutoquitAktiv 		:= FALSE;
		bModuloBetrArt 		:= FALSE;
		
		// NC-Achse initialisieren
		NC_Axis_OUT_bSteuerwortBit1 := FALSE;
		tonNotPosiFrg(IN := FALSE);
		
		// Übergang zur Bereitschaft
		IF I_bTaktFrg 
			AND NOT I_bGrundstellung 
		THEN
			nStep := 10;
		END_IF
(*================================================================================================================*)
	10: (* === BEREITSCHAFT === *)
		sStep := 'Bereitschaft';
		
		// Fehlermerker zurücksetzen
		nFehlerSchrittMerker := 0;
		bTiefeBeimAufsetzenOK := FALSE;
		bTiefeOkMem := FALSE;
		bDrehmomOkMem := FALSE;
		bDrehwinkelOkMem := FALSE;
		bModuloBetrArt := TRUE;
		nDrehwinkelMem := 0;
		nPD_Drehmoment :=	0; 
		nPD_Tiefe :=	0; 
		nPD_Drehwinkel :=	0;
		
		// Drehmoment Vorgabe errechnen 
		m_DrehmomentVorgabe(
			nSkalierung :=			nDrehmomentSkalierVorgabe,
			nTorque:= 				I_stParam.fParam_Sollmoment, 
			nRatedCurrentMotor:= 	nNennleistungMotor, 
			nTorqueConstant:= 		nDrehmomentKonstante, 
			nTorqueLimitation=> 	nSollDrehmomentErrechnet);
		
		// Watchdog für NC-Positionierung
		tonNotPosiFrg(
			IN := (NOT NC_Axis_IN_bPTPPosiFreig
				   AND NC_Axis_IN_bDCStatuswort13)
				  OR NC_Axis_IN_bNcFehler,
			PT := T#10S);
		
		// Achsen-Reset bei NC-Fehler
		bAchsreset := tonNotPosiFrg.Q 
						AND bTakt2langsam;
		
		// NC-Achse für normalen Betrieb konfigurieren
		IF NOT I_bReferenzfahrtAktiv 
		THEN
			NC_Axis_OUT_bSteuerwortBit1 := FALSE;
			NC_Axis_OUT_bIstwertSetzen := FALSE;
			NC_Axis_OUT_bAchsePosStarten := FALSE;
		END_IF
		
		// Schrauber freigeben nach Nachschießen
		IF I_bSchraubeNachschiessen 
		THEN
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
		END_IF
		
		// === BETRIEBSARTEN-AUSWAHL ===
		
		// AUSWERFEN: Manuelle Schraubenentfernung
		IF (bSchrAuswurfStart 
			OR IQ_fbObjSchlauch.I_bSchrAuswurfStart 
		    OR IQ_fbObjSchlauch.I_bTasteVereinzelung) 
		   AND NOT I_bTaktStop 
		THEN
			IQ_fbObjSchlauch.I_bSchrAuswurfStart := FALSE;
			bSchrAuswurfStart := FALSE;
			tonTimeOver1(IN := FALSE);
			nStep := 200;	(* -> Auswurfsequenz *)
			bAchsreset := FALSE;
		
		// NACHLADEN: Schraube aus Schlauch nachladen
		ELSIF NOT IQ_fbObjSchlauch.I_bSchrauberBelegt 
			  AND IQ_fbObjSchlauch.I_bSchlauchBelegt 
			  AND NOT I_bQuittFehler 
			  AND NOT I_bTaktStop 
		THEN
			
			IF I_bHuettenSchr 
			THEN
				// Sonderbehandlung für Hüttenhölscher-Schrauber
				tonTimeOver1(IN := TRUE, PT := T#0MS);
				bSchrAuswurf := FALSE;
				
				IF tonTimeOver1.Q
				THEN
					tonTimeOver1(IN := FALSE);
					nStep := 11;	(* -> Nachladen *)
				END_IF
			ELSE
				bSchrAuswurf := TRUE;
				nStep := 11;		(* -> Nachladen *)
			END_IF
			bAchsreset := FALSE;
		
		// VOLLSCHRAUBUNG: Schienenschrauben komplett einschrauben
		ELSIF IQ_fbObjSchlauch.I_bSchrauberBelegt 
			  AND I_bTaktStart 
			  AND NOT I_bTaktStop 
			  AND NOT I_bTaktStartHalb 
			  AND arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg 
			  AND I_bTaktFrg 
			  AND NOT I_bQuittFehler 
		THEN
			
			// NC-Achse für Schraubvorgang konfigurieren
			NC_Axis_OUT_bSteuerwortBit1 := TRUE;
			NC_Axis_OUT_bIstwertSetzen := TRUE;
			NC_Axis_OUT_nPosIstwertSetzen := 0;
			Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet);
			Q_bDrehmomentFehler := FALSE;
			
			bAchsreset := FALSE;
			nStep := 20;	(* -> Schraubstart *)
		
		// HALBSCHRAUBUNG: Schraube nur teilweise einschrauben (z.B. Metalltraverse)
		ELSIF IQ_fbObjSchlauch.I_bSchrauberBelegt 
			  AND NOT I_bTaktStart 
			  AND I_bTaktStartHalb 
			  AND NOT I_bTaktStop 
			  AND NC_Axis_IN_bPTPPosiFreig
			  AND I_bTaktFrg 
			  AND NOT I_bQuittFehler 
		THEN
			
			// NC-Achse für Halbschraubung konfigurieren
			NC_Axis_OUT_bSteuerwortBit1 := TRUE;
			NC_Axis_OUT_bIstwertSetzen := TRUE;
			NC_Axis_OUT_nPosIstwertSetzen := 0;
			Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet);
						
			bAchsreset := FALSE;
			nStep := 20;	(* -> Schraubstart *)
		END_IF
(*================================================================================================================*)
	// ================================================================================
	// NACHLADESEQUENZ
	// ================================================================================
	
	11: (* === NACHLADEN AKTIV === *)
		sStep := 'Nachladen_Aktiv';
		
		// Warten bis Schrauber belegt oder manuelle Vereinzelung
		IF (IQ_fbObjSchlauch.I_bSchrauberBelegt 
		    OR IQ_fbObjSchlauch.I_bTasteVereinzelung) 
		   AND NOT IQ_fbObjSchlauch.I_bNachladenaktiv 
		THEN
			bSchrAuswurf := FALSE;
			tonTimeOver1(IN := FALSE);
			nStep := 12;
		END_IF

	12: (* === NACHLADEN ABWARTEN === *)
		sStep := 'Nachladen_Wartepause';
		
		// Kurze Wartepause nach Nachladen
		tonTimeOver1(
			IN := TRUE, 
			PT := T#200MS);
		
		IF tonTimeOver1.Q 
		THEN
			bSchrAuswurf := FALSE;
			nStep := 10;	(* -> Zurück zur Bereitschaft *)
		END_IF
(*================================================================================================================*)
	// ================================================================================
	// SCHRAUBSEQUENZ
	// ================================================================================
	
	20: (* === SCHRAUBSTART VORBEREITUNG === *)
		sStep := 'Schraubstart_Vorbereitung';
		tonTimeOver1(IN := FALSE);
		
		// Warten auf alle Startbedingungen
		IF IQ_fbObjSchlauch.I_bSchrauberBelegt 
		   AND (I_bTaktStart 
			OR I_bTaktStartHalb) 
		   AND I_bTaktFrg 
		   AND NOT I_bQuittFehler 
		THEN
			nStep := 30;	(* -> Zustellung *)
		END_IF
(*================================================================================================================*)
	30: (* === SCHRAUBHUB AUSFAHREN === *)
		sStep := 'Schraubhub_Ausfahren';
		
		// Watchdog für Zustellvorgang
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdZustellhubSchr);
			
		tonTimeOutSchrauber(IN := FALSE);
		
		bSchraubHub := TRUE;
		
		// Warten auf Zustellung oder Endlage
		IF I_bTaktFrg 
			AND (tonTimeOver1.Q 
			OR I_bZustellZylAusgef) 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 40;	(* -> Aufsetzen *)
		END_IF
(*================================================================================================================*)
	40: (* === AUFSETZVORGANG === *)
		sStep := 'Aufsetzen_auf_Werkstueck';
		
		// Watchdog für Aufsetzvorgang
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdSchraubhubSchr);
			
		tonTimeOutSchrauber(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdSchraubhubSchr + T#2S);
		
		// Tiefe beim ersten Kontakt merken
		nTiefeBeimAufsetzen := fSchraubTiefeIst;
		bSchrAuswurf := TRUE;
				
		m_TiefenPruefung(
			nSolltiefeMin:= 	nMinimalAufsetztiefe, 
			nSolltiefeMax:= 	nMinimalAufsetztiefe, 
			nToleranz:= 		nMinimalAufsetztiefeToleranz,	 
			nActTiefe:= 		nTiefeBeimAufsetzen, 
			bTiefeOk=> 			bTiefeBeimAufsetzenOK);
			
		// Fehlerbehandlung: Schraube fehlt
		IF tonTimeOver1.Q 
			AND I_bTaktFrg 
		   	AND F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := I_stParam.fParam_Sollschraubtiefe - 100,
			I_fMaximalValue := I_stParam.fParam_Sollschraubtiefe) 
		THEN
			
			// Schraubvorgang abbrechen - Schraube fehlt
			tonTimeOver1(IN := FALSE);
			bSchraubHub := FALSE;
			bSchrAuswurf := FALSE;
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := FALSE;
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
			nFehlerZaehler := nFehlerZaehler + 1;
			nStep := -40;	(* -> Fehler: Schraube fehlt *)
		
		// Übergang zur Anlaufphase
		ELSIF tonTimeOver1.Q 
			AND I_bTaktFrg 
			AND NC_Axis_IN_bIstWertgesetzt
			AND NC_Axis_IN_bPTPPosiFreig
			AND ((fSchraubTiefeIst <= nMinimalAufsetztiefe+nMinimalAufsetztiefeToleranz) 
			OR tonTimeOutSchrauber.Q) 
		THEN
			
			// Statistik für Schraubspitzenklemmer
			IF tonTimeOutSchrauber.Q 
			THEN
				nAnzahlSchraubspitzenKlemmer := nAnzahlSchraubspitzenKlemmer + 1;
			END_IF
			
			tonTimeOutSchrauber(IN := FALSE);
			tonTimeOver1(IN := FALSE);
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := FALSE;
			nStep := 45;	(* -> Anlaufphase *)
		END_IF
(*================================================================================================================*)
	45: (* === ANLAUFPHASE - LANGSAME DREHZAHL === *)
		sStep := 'Anlaufphase_Langsam';
		
		// Watchdog für Anlaufphase
		tonTimeOver1(
			IN := TRUE, 
			PT := T#5S);
		
		// Startdrehzahl setzen
		NC_Axis_OUT_nPTPVelo := I_stParam.fStartDrehzahl;
		NC_Axis_OUT_PTPBuffMode := MC_Aborting;
		NC_Axis_OUT_bAchsePosStarten := I_bTaktFrg;
		
		// Prüfung ob 80% der Sollgeschwindigkeit erreicht
		IF (arrNcAchsen[I_nAchsId].stStatus.bFaehrtPos 
		    AND ((NC_Axis_OUT_nPTPVelo * 0.8) 
			     > (NC_Axis_IN_nActVelo
				    / NC_Axis_IN_nParamEilgeschw * 100))) 
		THEN
			
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;
			tonTimeOver1(IN := FALSE);
			nStep := 50;	(* -> Hauptschraubphase *)
			
		ELSIF tonTimeOver1.Q 
		THEN
			// Timeout - Geschwindigkeit nicht erreicht
			tonTimeOver1(IN := FALSE);
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -45;	(* Fehlercode merken *)
		END_IF
(*================================================================================================================*)
	50: (* === HAUPTSCHRAUBPHASE - GESCHWINDIGKEIT AUFBAUEN === *)
		sStep := 'Hauptschraubphase_Beschleunigen';
		
		// Watchdog für Beschleunigungsphase
		tonTimeOver1(
			IN := TRUE, 
			PT := T#3S);
			
		arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;
		
		(* Prozessdaten Tiefe Schreiben *)
		nPD_Tiefe:=	fSchraubTiefeIst;
		
		// Umschaltung auf Solldrehzahl basierend auf Schraubtiefe
		IF I_bTaktStart 
			AND fSchraubTiefeIst < 
				I_stParam.fSchraubTiefeSollDrehzahl 
		THEN
			// Vollschraubung
			NC_Axis_OUT_nPTPVelo := I_stParam.fParam_Solldrehzahl;
			NC_Axis_OUT_PTPBuffMode := MC_BlendingNext;
			NC_Axis_OUT_bAchsePosStarten := I_bTaktFrg;
			nStep := 60;	(* -> Tiefenprüfung *)
			
		ELSIF I_bTaktStartHalb 
		THEN
			// Halbschraubung
			NC_Axis_OUT_nPTPVelo := I_stParam.fParam_Solldrehzahl * nSkalDrehzReduzHalb;
			NC_Axis_OUT_PTPBuffMode := MC_BlendingNext;
			NC_Axis_OUT_bAchsePosStarten := I_bTaktFrg;
			nStep := 60;	(* -> Tiefenprüfung *)
			
		ELSIF tonTimeOver1.Q 
		THEN
			// Timeout - Solltiefe für Drehzahlumschaltung nicht erreicht
			tonTimeOver1(IN := FALSE);
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -50;	(* Fehlercode merken *)
		END_IF
(*================================================================================================================*)
	60: (* === TIEFENPRÜFUNG === *)
		sStep := 'Tiefenpruefung_Solltiefe';
		
		// Watchdog für Schraubvorgang
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdSchraubTakt);
			
		NC_Axis_OUT_bAchsePosStarten := I_bTaktFrg;
		
		IF I_bTaktStart
		THEN
			m_TiefenPruefung(
				nSolltiefeMin:= 	nMinimalSchraubtiefe, 
				nSolltiefeMax:= 	I_stParam.fParam_Sollschraubtiefe, 
				nToleranz:= 		0,	 
				nActTiefe:= 		fSchraubTiefeIst, 
				bTiefeOk=> 			bTiefeOkMem);
		ELSIF
			I_bTaktStartHalb
		THEN
			m_TiefenPruefung(
				nSolltiefeMin:= 	nMinimalSchraubtiefeHalb, 
				nSolltiefeMax:= 	I_stParam.fParam_SollschraubtiefeHerdumbau, 
				nToleranz:= 		0,	 
				nActTiefe:= 		fSchraubTiefeIst, 
				bTiefeOk=> 			bTiefeOkMem);
		END_IF
		
		(* Prozessdaten Tiefe Schreiben *)
		IF fSchraubTiefeIst < nPD_Tiefe
		THEN
			nPD_Tiefe:=	fSchraubTiefeIst;
		END_IF
		
		// Prüfung Solltiefe erreicht
		IF bTiefeOkMem
		THEN
			tonTimeOver1(IN := FALSE);
			nPosMerkerTiefeOk :=	NC_Axis_IN_nActPos;	(* Achs Positionswert Speichern *)
			// Drehzahl für Feineinstellung reduzieren
			NC_Axis_OUT_nPTPVelo := I_stParam.fParam_Solldrehzahl * nSkalDrehzReduzTiefeOk;	
			nStep := 62;	(* -> Drehmomentprüfung *)	(* Tiefe mit Voreingestelltem Drehmoment Erreicht, nun Drehwinkelprüfung *)
		ELSIF		
			// Timeout - Solltiefe nicht erreicht
			 tonTimeOver1.Q 
			 AND NOT bTiefeOkMem
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -60;	(* Fehlercode merken *)
		END_IF
(*================================================================================================================*)
	62: (* === Drehwinkelprüfung&  Drehmoment Prüfung === *)
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdSchraubTakt);
			
		(* Aufruf Drehwinkel Prüfen *)
		m_DrehwinkelPruefung(
			nPosAct:= 			NC_Axis_IN_nActPos, 
			nPosMem:= 			nPosMerkerTiefeOk, 
			nPosSoll:= 			nSollDrehwinkelNachTiefeOK, 
			nMaxDrehwinkel :=	nMaxDrehwinkelNachTiefeOk,
			bWinkelOk=> 		bDrehwinkelOkMem,
			nWinkelAct=>		nDrehwinkelMem);
		
		(* Aufruf Drehmoment Prüfen *)
		m_DrehmomentPruefung(
			nDrehmomentSoll:= 		I_stParam.fParam_Sollmoment, 
			bDrehmomentOk=> 		bDrehmomOkMem);
		
		(* Prozessdaten Tiefe Schreiben *)
		IF fSchraubTiefeIst < nPD_Tiefe
		THEN
			nPD_Tiefe:=	fSchraubTiefeIst;
		END_IF
		
		(* Prozessdaten Drehmoment Schreiben *)
		IF fDrehmomentIstMittel >nPD_Drehmoment
		THEN
			nPD_Drehmoment :=	fDrehmomentIstMittel;
		END_IF
		
		(* Prozessdaten Drehwinkel Schreiben *)
		IF nDrehwinkelMem> nPD_Drehwinkel
		THEN
			nPD_Drehwinkel :=	nDrehwinkelMem;
		END_IF
		
		(* Auswertung *)
		IF bDrehwinkelOkMem
			AND bDrehmomOkMem
		THEN
			nStep := 70;
		ELSIF
			tonTimeOver1.Q
		THEN
			IF bDrehwinkelOkMem
				AND NOT bDrehmomOkMem
			THEN
				nStep := 70;	(* -> Motor stoppen *)
				nFehlerSchrittMerker := -65;	(* Fehlercode merken *)
			ELSIF
				NOT bDrehwinkelOkMem
				AND bDrehmomOkMem
			THEN
				nStep := 70;	(* -> Motor stoppen *)
				nFehlerSchrittMerker := -62;	(* Fehlercode merken Drehwinkel*)
			ELSIF
				NOT bDrehwinkelOkMem
				AND NOT bDrehmomOkMem
			THEN
				nStep := 70;	(* -> Motor stoppen *)
				nFehlerSchrittMerker := -63;	(* Fehlercode merken Drehwinkel*)
			END_IF
			
		END_IF
(*================================================================================================================*)
	65: (* === DREHMOMENTPRÜFUNG === *)
		sStep := 'Drehmomentpruefung_Sollmoment';
			
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdSchraubTakt);
						
		m_DrehmomentPruefung(
			nDrehmomentSoll:= 		I_stParam.fParam_Sollmoment, 
			bDrehmomentOk=> 		bDrehmomOkMem);
			
		(* Prozessdaten Tiefe Schreiben *)
		IF fSchraubTiefeIst < nPD_Tiefe
		THEN
			nPD_Tiefe:=	fSchraubTiefeIst;
		END_IF
		
		(* Prozessdaten Drehmoment Schreiben *)
		IF fDrehmomentIstMittel >nPD_Drehmoment
		THEN
			nPD_Drehmoment :=	fDrehmomentIstMittel;
		END_IF
		
		IF bDrehmomOkMem
		THEN
			nStep := 70;
		ELSIF
			// Timeout-Behandlung
			tonTimeOver1.Q
		THEN
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -65;	(* Fehlercode merken *)
		END_IF
			
		// Spezialfall: Tiefe überschritten ohne korrektes Aufsetzen
		IF fSchraubTiefeIst <= 
			I_stParam.fParam_Sollschraubtiefe - 10 
		   AND NOT bTiefeBeimAufsetzenOK 
		THEN
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -61;	(* Fehlercode merken *)
		END_IF
(*================================================================================================================*)
	70: (* === MOTOR STOPPEN === *)
		sStep := 'Motor_Stoppen';
		Q_nTorque := 0;
		
		// Watchdog für Stoppvorgang
		tonTimeOver1(
			IN := TRUE, 
			PT := T#1000MS);
		
		// Achse stoppen
		arrStartAusf[I_nAchsId].I_bAchseStopPos := TRUE;
		
		// Warten auf Stillstand
		IF tonTimeOver1.Q 
		   OR NC_Axis_IN_bInPos
		THEN
			tonTimeOver1(IN := FALSE);
			NC_Axis_OUT_bAchsePosStarten := FALSE;
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
			nStep := 75;	(* -> Stillstand abwarten *)
		END_IF
(*================================================================================================================*)
	75: (* === STILLSTAND ABWARTEN === *)
		sStep := 'Stillstand_Abwarten';
		
		// Watchdog für Stillstand
		tonTimeOver1(
			IN := TRUE, 
			PT := T#2000MS);
		
		// Warten auf Motorstillstand
		IF tonTimeOver1.Q 
			OR arrNcAchsen[I_nAchsId].stStatus.bInStillst 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 80;	(* -> Rückfahrt vorbereiten *)
		END_IF
(*================================================================================================================*)
	80: (* === RÜCKFAHRT VORBEREITEN === *)
		sStep := 'Rueckfahrt_Vorbereiten';
		
		// Watchdog für Rückfahrt
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdAuswurfSchr);
			
		bSchrAuswurf := FALSE;
		
		m_TiefenPruefung(
			nSolltiefeMin:= 	80, 
			nSolltiefeMax:= 	80, 
			nToleranz:= 		10,	 
			nActTiefe:= 		fSchraubTiefeIst, 
			bTiefeOk=> 			bTiefeOkMem);
				
		// Prüfung ob Rückfahrposition erreicht
		IF bTiefeOkMem
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 85;	(* -> Schraubhub einfahren *)
		ELSIF tonTimeOver1.Q 
		THEN
			tonTimeOver1(IN := FALSE);
			bSchraubHub := FALSE;
			nStep := 90;	(* -> Grundstellung *)
			nFehlerSchrittMerker := -80;	(* Fehlercode merken *)
		END_IF
(*================================================================================================================*)
	85: (* === SCHRAUBHUB EINFAHREN === *)
		sStep := 'Schraubhub_Einfahren';
		
		bSchraubHub := FALSE;
		nStep := 90;	(* -> Grundstellung *)
(*================================================================================================================*)
	90: (* === GRUNDSTELLUNG ANFAHREN === *)
		sStep := 'Grundstellung_Anfahren';
		
		// Warten auf Grundstellung
		IF I_bGrdstlgSchrEinh 
			AND I_bTaktFrg 
		THEN
			NC_Axis_OUT_bSteuerwortBit2 := TRUE;	(* Referenzierung *)
			bAchsreset := TRUE;
			nStep := 95;	(* -> Referenzierung *)
		END_IF
(*================================================================================================================*)
	95: (* === ACHSE REFERENZIEREN === *)
		sStep := 'Achse_Referenzieren';
		
		bAchsreset := FALSE;
		
		// Warten auf Referenzierung
		IF NC_Axis_IN_bStatuswortBit0 
		   OR I_nMotorHersteller = 1 (* Bei Beckhoff Motor überspringen *)
		THEN
			
			NC_Axis_OUT_bSteuerwortBit2 := FALSE;
			
			// Fehlerbehandlung oder erfolgreich beenden
			IF nFehlerSchrittMerker <> 0 
			THEN
				nFehlerZaehler := nFehlerZaehler + 1;
				nStep := nFehlerSchrittMerker;	(* -> Fehlerbehandlung *)
				nFehlerSchrittMerker := 0;
			ELSE
				nStep := 100;	(* -> Erfolgreich beendet *)
			END_IF
		END_IF
(*================================================================================================================*)
	100: (* === VORGANG ERFOLGREICH BEENDET === *)
		sStep := 'Vorgang_Beendet';
		
		// Warten auf Freigabe für nächsten Zyklus
		IF NOT I_bTaktStart 
			AND NOT I_bTaktStartHalb
		THEN
			Q_nTorque := 300;	
			bAutoquitAktiv := FALSE;
			NC_Axis_OUT_bSteuerwortBit1	:= FALSE;
			NC_Axis_OUT_bAchsePosStarten := FALSE;
			nStep := 10;	(* -> Zurück zur Bereitschaft *)
		END_IF
(*================================================================================================================*)
	// ================================================================================
	// AUSWURFSEQUENZ
	// ================================================================================
	
	200: (* === AUSWURF START === *)
		sStep := 'Auswurf_Start';
		
		// Watchdog für Auswurf-Freigabe
		tonTimeOver1(
			IN := TRUE, 
			PT := T#10S);
		
		IF I_bTaktFrg 
			AND I_bFreigabeAuswerfen 
			OR tonTimeOver1.Q 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 205;	(* -> Auswurf Zustellung *)
		END_IF

	205: (* === AUSWURF ZUSTELLUNG === *)
		sStep := 'Auswurf_Zustellung';
		
		// Watchdog für Zustellung
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdZustellhubSchr);
			
		bSchraubHub := TRUE;
		
		IF I_bTaktFrg 
			AND (tonTimeOver1.Q 
			OR I_bZustellZylAusgef) 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 210;	(* -> Auswurf ausfahren *)
		END_IF
(*================================================================================================================*)
	210: (* === AUSWURF AUSFAHREN === *)
		sStep := 'Auswurf_Ausfahren';
		
		// Watchdog für Auswurfvorgang
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdAuswurfSchr);
			
		bSchrAuswurf := TRUE;
		
		m_TiefenPruefung(
			nSolltiefeMin:= 	I_fSchraubTiefeAuswurf-100, 
			nSolltiefeMax:= 	I_fSchraubTiefeAuswurf+1, 
			nToleranz:= 		0,	 
			nActTiefe:= 		fSchraubTiefeIst, 
			bTiefeOk=> 			bTiefeOkMem);
			
		// Prüfung Auswurfposition erreicht
		IF bTiefeOkMem
		THEN
			nStep := 230;	(* -> Auswurf aktiv *)
		ELSIF tonTimeOver1.Q
		THEN
			tonTimeOver1(IN := FALSE);
			bSchrAuswurf := FALSE;
			nStep := 215;	(* -> Wiederholungsversuch *)
		END_IF
(*================================================================================================================*)
	215: (* === AUSWURF PAUSE === *)
		sStep := 'Auswurf_Pause';
		
		tonTimeOver1(
			IN := TRUE, 
			PT := T#100MS);
			
		IF tonTimeOver1.Q 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 220;	(* -> Auswurf wiederholen *)
		END_IF
(*================================================================================================================*)
	220: (* === AUSWURF WIEDERHOLEN === *)
		sStep := 'Auswurf_Wiederholen';
		
		// Watchdog für Wiederholungsversuch
		tonTimeOver1(
			IN := TRUE, 
			PT := I_stParam.tParam_ZeitdAuswurfSchr);
			
		bSchrAuswurf := TRUE;
		
		m_TiefenPruefung(
			nSolltiefeMin:= 	I_fSchraubTiefeAuswurf-100, 
			nSolltiefeMax:= 	I_fSchraubTiefeAuswurf+1, 
			nToleranz:= 		0,	 
			nActTiefe:= 		fSchraubTiefeIst, 
			bTiefeOk=> 			bTiefeOkMem);
			
		// Prüfung Auswurfposition erreicht
		IF bTiefeOkMem
		THEN
			nStep := 230;	(* -> Auswurf aktiv *)
			tonTimeOver1(IN := FALSE);
		ELSIF 
			tonTimeOver1.Q 
		THEN
			bSchrAuswurf := FALSE;
			bSchraubHub := FALSE;
			nStep := -210;	(* -> Fehler Auswurf *)
			tonTimeOver1(IN := FALSE);
		END_IF
(*================================================================================================================*)
	230: (* === AUSWURF AKTIV === *)
		sStep := 'Auswurf_Aktiv';
		
		IF I_bTaktFrg 
		THEN
			nStep := 240;	(* -> Auswurf zurückfahren *)
		END_IF
(*================================================================================================================*)
	240: (* === AUSWURF ZURÜCKFAHREN === *)
		sStep := 'Auswurf_Zurueckfahren';
		
		// Watchdog für Rückfahrt
		tonTimeOver1(
			IN := TRUE, 
			PT := T#1000MS);
			
		bSchrAuswurf := FALSE;
		bSchraubHub := FALSE;
		
		m_TiefenPruefung(
			nSolltiefeMin:= 	I_fSchraubTiefeAuswurf-100, 
			nSolltiefeMax:= 	I_fSchraubTiefeAuswurf+1, 
			nToleranz:= 		0,	 
			nActTiefe:= 		fSchraubTiefeIst, 
			bTiefeOk=> 			bTiefeOkMem);
			
		// Prüfung Ausgangsposition erreicht
		IF NOT bTiefeOkMem 
		   AND NOT I_bZustellZylAusgef 
		THEN
			nStep := 250;	(* -> Auswurf beendet *)
			tonTimeOver1(IN := FALSE);
			
		ELSIF 
			tonTimeOver1.Q 
		THEN
			bSchrAuswurf := FALSE;
			bSchraubHub := FALSE;
			nStep := -210;	(* -> Fehler Auswurf *)
			tonTimeOver1(IN := FALSE);
		END_IF
(*================================================================================================================*)
	250: (* === AUSWURF BEENDET === *)
		sStep := 'Auswurf_Beendet';
		
		Q_nErrorId := 0;
		
		IF I_bTaktFrg 
			AND NOT IQ_fbObjSchlauch.I_bTasteVereinzelung 
		THEN
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
			bAutoquitAktiv := FALSE;
			nStep := 10;	(* -> Zurück zur Bereitschaft *)
		END_IF
(*================================================================================================================*)
	// ================================================================================
	// FEHLERBEHANDLUNG
	// ================================================================================
	
	-40: (* === FEHLER: SCHRAUBE FEHLT === *)
		sStep := 'FEHLER_Schraube_fehlt';
		Q_nErrorId := -40;
		
		IF I_bQuittFehler
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-45: (* === FEHLER: LANGSAME GESCHWINDIGKEIT === *)
		sStep := 'FEHLER_Langsame_Geschwindigkeit';
		Q_nErrorId := -45;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-50: (* === FEHLER: SCHRAUBTIEFE FÜR SOLLDREHZAHL === *)
		sStep := 'FEHLER_Schraubtiefe_Solldrehzahl';
		Q_nErrorId := -50;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-60: (* === FEHLER: SOLLTIEFE NICHT ERREICHT === *)
		sStep := 'FEHLER_Solltiefe_nicht_erreicht';
		Q_nErrorId := -60;
		Q_bDrehmomentFehler := TRUE;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-61: (* === FEHLER: SOLLTIEFE ÜBERSCHRITTEN === *)
		sStep := 'FEHLER_Solltiefe_ueberschritten';
		Q_nErrorId := -61;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-62: (* === FEHLER: SOLLTIEFE ÜBERSCHRITTEN === *)
		sStep := 'FEHLER_DrehwinkelNichtOk_DrehmomentOk';
		Q_nErrorId := -62;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-63: (* === FEHLER: SOLLTIEFE ÜBERSCHRITTEN === *)
		sStep := 'FEHLER_DrehomomentNichtOk_DrehwinkelNichtOk';
		Q_nErrorId := -63;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-65: (* === FEHLER: SOLLDREHMOMENT NICHT ERREICHT === *)
		sStep := 'FEHLER_Solldrehmoment_nicht_erreicht';
		Q_nErrorId := -65;
		
		IF I_bQuittFehler
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-80: (* === FEHLER: SCHRAUBERSTANGE === *)
		sStep := 'FEHLER_Schrauberstange_Bewegung';
		Q_nErrorId := -80;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF
(*================================================================================================================*)
	-210: (* === FEHLER: AUSWURF === *)
		sStep := 'FEHLER_Auswurf_Vorgang';
		Q_nErrorId := -210;
		
		IF I_bQuittFehler 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 240;	(* -> Auswurf zurückfahren *)
		END_IF

	END_CASE
	
ELSE
	// === RESET AKTIV ===
	nStep := 0;
END_IF

// ================================================================================
// ALLGEMEINE FUNKTIONEN UND ÜBERWACHUNG
// ================================================================================

// === GRUNDSTELLUNG ERZWINGEN ===
IF I_bGrundstellung 
THEN
	nStep := 0;
END_IF

// === AUTOMATISCHE QUITTIERUNG ===
tonAutoquit(
	IN := (Q_bError 
			AND I_tAutoQuit > T#0MS), 
	PT := I_tAutoQuit);

// === POSITIONSZUSTANDS-STRING ===
Q_sPosZustand := F_PosZustand(
	I_sString := I_sPosBeschreibung, 
	I_nStep := nStep, 
	I_sStep := sStep);

// === IST-SCHRAUBTIEFE AKTUALISIEREN ===
fSchraubTiefeIst := arrNcAchsen[I_nEncId].fPosIstwert;

// === TIMER FÜR SCHRITTÜBERWACHUNG ===
tonDelay1(IN := nStep = nOldStep, PT := T#1D);
nOldStep := nStep;

// === STEP-HISTORIE ===
fbStepHistory(I_nStep := nStep);]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_LoggingUndDiagnose" Id="{90a39e0d-f853-4a33-98ea-82180c6e1800}">
      <Declaration><![CDATA[METHOD m_LoggingUndDiagnose : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
LOGGING UND DIAGNOSE
================================================================================
Zentrale Verwaltung aller Log-Funktionen und statistischen Auswertungen.
Speichert Fehler, Schraubzeiten und Prozessdaten für Qualitätssicherung.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === STÜCKZÄHLER ===
rtrigStueckzaehler(CLK := Q_bDone);
IF rtrigStueckzaehler.Q THEN
	nStueckzaehler := nStueckzaehler + 1;
END_IF

// === FEHLER-LOGGING ===
rtrigSchrauberfehler(CLK := nStep < 0 AND I_stParam.bLogAnwahl);

fbLogToFile(
	I_bStart 			:= rtrigSchrauberfehler.Q,
	I_sDateipfad 		:= I_sDateipfad,
	I_sDateiname 		:= I_sPosBeschreibung,
	I_sUeberschrift 	:= 'Timestamp;Anzahl;Schraubzeit;Drehmoment;Schraubtiefe;Barcode;Fehlermeldung;$R',
	
	// Fehlerzustände
	I_bFehler1 			:= objError_Schrauber.I_fbFehler_Schrauberstange.I_bAktiv,
	I_bFehler2 			:= objError_Schrauber.I_fbFehler_Sollmoment.I_bAktiv,
	I_bFehler3 			:= objError_Schrauber.I_fbFehler_Tiefe.I_bAktiv,
	I_bFehler4 			:= objError_Schrauber.I_fbFehler_TiefeUeberschritten.I_bAktiv,
	I_bFehler5 			:= objError_Schrauber.I_fbFehlerAuswurf.I_bAktiv,
	I_bFehler6 			:= objError_Schrauber.I_fbFehlerLangsameGeschwindigkeit.I_bAktiv,
	I_bFehler7 			:= objError_Schrauber.I_fbFehlerNachladen.I_bAktiv,
	I_bFehler8 			:= objError_Schrauber.I_fbFehlerTiefeSolldrehzahl.I_bAktiv,
	
	// Fehlerbeschreibungen
	I_sFehler1 			:= 'Fehler beim heben/senken der Schrauberstange',
	I_sFehler2 			:= 'Fehler - Drehmoment wird nicht erreicht',
	I_sFehler3 			:= 'Fehler - Tiefe wird nicht erreicht',
	I_sFehler4 			:= 'Fehler - Tiefe ueberschritten',
	I_sFehler5 			:= 'Fehler - Auswerfen',
	I_sFehler6 			:= 'Fehler - Langsame Geschwindigkeit wird nicht erreicht',
	I_sFehler7 			:= 'Fehler - Schraube fehlt',
	I_sFehler8 			:= 'Fehler - Schraubtiefe für Solldrehzahl wird nicht erreicht',
	
	// Prozessdaten
	I_sBarcode 			:= '',
	I_nAnzahlVerschraubungen := nStueckzaehler,
	I_tSchraubzeit 		:= arrLetzteSchraubzeit[0],
	I_fDrehmoment 		:= arrLetzteMomente[0],
	I_fSchraubtiefe 	:= arrLetzteTiefe[0]);

// === LOG BEENDEN BEI ERFOLG ===
IF Q_bDone THEN
	fbLogToFile(I_bStart := FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_SchraubtaktMessung" Id="{7fa50d8c-cc7c-4c13-a4fe-7f70413fdf01}">
      <Declaration><![CDATA[METHOD m_SchraubtaktMessung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
SCHRAUBTAKT-ZEITMESSUNG
================================================================================
Misst die Schraubzeit für Diagnose und Optimierung.
Die Zeitmessung erfolgt während der aktiven Schraubphase.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === ZEITMESSUNG WÄHREND SCHRAUBPHASE ===
tonSchraubtakt(
	IN := nStep = 60 OR nStep = 160 OR nStep = 65,
	PT := T#100S);

// === ZEIT ERFASSEN ===
IF nStep = 60 OR nStep = 160 OR nStep = 65 THEN
	timeSchraubtakt := tonSchraubtakt.ET;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_StillstandsUeberwachung" Id="{059a933a-b340-41dd-b7fe-570794430256}">
      <Declaration><![CDATA[METHOD m_StillstandsUeberwachung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
STILLSTANDS-ÜBERWACHUNG
================================================================================
Überwacht den Stillstand von Achsen mit Verzögerung zur Vermeidung
von Fehlmeldungen bei kurzen Bewegungspausen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === VERZÖGERTER STILLSTAND ===
tonVerzStillstand(
	IN := NC_Axis_IN_bInStillstand,
	PT := T#10MS);]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_TiefenPruefung" Id="{2bc256ea-8be1-426a-ba13-92e126ca7201}">
      <Declaration><![CDATA[METHOD m_TiefenPruefung : BOOL
VAR_INPUT
	nSolltiefeMin	:LREAL;
	nSolltiefeMax	:LREAL;
	nToleranz	:LREAL;
	nActTiefe	:LREAL;
END_VAR
VAR_OUTPUT
	bTiefeOk	:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Prüfung der Aufsetztiefe
IF F_Inbetween(
	I_fActualValue := nActTiefe,
	I_fMinimalValue := nSolltiefeMin - nToleranz,		(* Sollaufsetztiefe ± Toleranz *)
	I_fMaximalValue := nSolltiefeMax + nToleranz) 
THEN
	bTiefeOk := TRUE;
ELSE
	bTiefeOk := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Schrauber_PnP_3_V01">
      <LineId Id="222" Count="17" />
      <LineId Id="733" Count="10" />
      <LineId Id="730" Count="0" />
      <LineId Id="744" Count="0" />
      <LineId Id="731" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="732" Count="0" />
      <LineId Id="241" Count="7" />
      <LineId Id="9" Count="0" />
      <LineId Id="477" Count="0" />
      <LineId Id="475" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_AchsKommunikation">
      <LineId Id="6" Count="21" />
      <LineId Id="5" Count="0" />
      <LineId Id="28" Count="2" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_Ausgangszuweisung">
      <LineId Id="13" Count="2" />
      <LineId Id="48" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="17" Count="2" />
      <LineId Id="50" Count="0" />
      <LineId Id="20" Count="4" />
      <LineId Id="51" Count="0" />
      <LineId Id="25" Count="3" />
      <LineId Id="52" Count="0" />
      <LineId Id="29" Count="18" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_DiagnoseHistorie">
      <LineId Id="13" Count="5" />
      <LineId Id="32" Count="0" />
      <LineId Id="19" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_DrehmomentMittelwert">
      <LineId Id="13" Count="1" />
      <LineId Id="36" Count="1" />
      <LineId Id="48" Count="4" />
      <LineId Id="17" Count="18" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_DrehmomentPruefung">
      <LineId Id="10" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="24" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_DrehmomentRechnung">
      <LineId Id="48" Count="1" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_DrehmomentVorgabe">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_DrehwinkelPruefung">
      <LineId Id="5" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_Fehlerbehandlung">
      <LineId Id="13" Count="56" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_HandleReset">
      <LineId Id="15" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_Hauptablauf">
      <LineId Id="14" Count="1" />
      <LineId Id="752" Count="0" />
      <LineId Id="16" Count="12" />
      <LineId Id="30" Count="7" />
      <LineId Id="753" Count="1" />
      <LineId Id="38" Count="8" />
      <LineId Id="985" Count="1" />
      <LineId Id="1069" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="1180" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="1048" Count="1" />
      <LineId Id="1185" Count="0" />
      <LineId Id="1051" Count="5" />
      <LineId Id="1050" Count="0" />
      <LineId Id="1057" Count="0" />
      <LineId Id="49" Count="8" />
      <LineId Id="755" Count="0" />
      <LineId Id="58" Count="2" />
      <LineId Id="756" Count="0" />
      <LineId Id="61" Count="6" />
      <LineId Id="757" Count="0" />
      <LineId Id="68" Count="6" />
      <LineId Id="758" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="759" Count="0" />
      <LineId Id="77" Count="10" />
      <LineId Id="760" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="761" Count="0" />
      <LineId Id="90" Count="4" />
      <LineId Id="762" Count="0" />
      <LineId Id="95" Count="16" />
      <LineId Id="763" Count="0" />
      <LineId Id="113" Count="18" />
      <LineId Id="764" Count="0" />
      <LineId Id="132" Count="6" />
      <LineId Id="144" Count="14" />
      <LineId Id="766" Count="0" />
      <LineId Id="159" Count="9" />
      <LineId Id="850" Count="1" />
      <LineId Id="169" Count="1" />
      <LineId Id="767" Count="0" />
      <LineId Id="171" Count="10" />
      <LineId Id="852" Count="0" />
      <LineId Id="182" Count="2" />
      <LineId Id="768" Count="0" />
      <LineId Id="185" Count="1" />
      <LineId Id="769" Count="0" />
      <LineId Id="189" Count="7" />
      <LineId Id="853" Count="4" />
      <LineId Id="197" Count="3" />
      <LineId Id="770" Count="2" />
      <LineId Id="201" Count="0" />
      <LineId Id="203" Count="7" />
      <LineId Id="858" Count="2" />
      <LineId Id="211" Count="0" />
      <LineId Id="861" Count="1" />
      <LineId Id="212" Count="3" />
      <LineId Id="866" Count="0" />
      <LineId Id="898" Count="6" />
      <LineId Id="225" Count="1" />
      <LineId Id="774" Count="0" />
      <LineId Id="227" Count="3" />
      <LineId Id="776" Count="0" />
      <LineId Id="231" Count="11" />
      <LineId Id="777" Count="0" />
      <LineId Id="243" Count="2" />
      <LineId Id="778" Count="1" />
      <LineId Id="246" Count="2" />
      <LineId Id="780" Count="0" />
      <LineId Id="249" Count="13" />
      <LineId Id="867" Count="1" />
      <LineId Id="263" Count="10" />
      <LineId Id="781" Count="0" />
      <LineId Id="274" Count="5" />
      <LineId Id="782" Count="0" />
      <LineId Id="280" Count="10" />
      <LineId Id="869" Count="2" />
      <LineId Id="291" Count="0" />
      <LineId Id="1026" Count="1" />
      <LineId Id="292" Count="0" />
      <LineId Id="1025" Count="0" />
      <LineId Id="293" Count="1" />
      <LineId Id="783" Count="0" />
      <LineId Id="872" Count="0" />
      <LineId Id="784" Count="0" />
      <LineId Id="295" Count="6" />
      <LineId Id="785" Count="0" />
      <LineId Id="302" Count="6" />
      <LineId Id="786" Count="0" />
      <LineId Id="309" Count="10" />
      <LineId Id="873" Count="2" />
      <LineId Id="320" Count="0" />
      <LineId Id="877" Count="2" />
      <LineId Id="905" Count="4" />
      <LineId Id="885" Count="3" />
      <LineId Id="910" Count="4" />
      <LineId Id="889" Count="0" />
      <LineId Id="880" Count="0" />
      <LineId Id="324" Count="0" />
      <LineId Id="1043" Count="3" />
      <LineId Id="1023" Count="0" />
      <LineId Id="1107" Count="0" />
      <LineId Id="325" Count="0" />
      <LineId Id="335" Count="0" />
      <LineId Id="787" Count="0" />
      <LineId Id="1077" Count="0" />
      <LineId Id="1058" Count="0" />
      <LineId Id="337" Count="2" />
      <LineId Id="341" Count="0" />
      <LineId Id="343" Count="0" />
      <LineId Id="345" Count="0" />
      <LineId Id="915" Count="0" />
      <LineId Id="789" Count="0" />
      <LineId Id="348" Count="0" />
      <LineId Id="1078" Count="1" />
      <LineId Id="349" Count="0" />
      <LineId Id="1060" Count="0" />
      <LineId Id="1059" Count="0" />
      <LineId Id="1074" Count="1" />
      <LineId Id="1062" Count="0" />
      <LineId Id="1076" Count="0" />
      <LineId Id="1178" Count="0" />
      <LineId Id="1061" Count="0" />
      <LineId Id="1063" Count="2" />
      <LineId Id="1102" Count="0" />
      <LineId Id="1066" Count="0" />
      <LineId Id="1179" Count="0" />
      <LineId Id="1085" Count="0" />
      <LineId Id="1177" Count="0" />
      <LineId Id="1157" Count="1" />
      <LineId Id="1155" Count="0" />
      <LineId Id="1067" Count="0" />
      <LineId Id="1091" Count="9" />
      <LineId Id="1090" Count="0" />
      <LineId Id="1175" Count="0" />
      <LineId Id="1101" Count="0" />
      <LineId Id="1170" Count="1" />
      <LineId Id="1173" Count="0" />
      <LineId Id="1172" Count="0" />
      <LineId Id="1174" Count="0" />
      <LineId Id="1176" Count="0" />
      <LineId Id="1068" Count="0" />
      <LineId Id="1089" Count="0" />
      <LineId Id="1070" Count="0" />
      <LineId Id="1072" Count="0" />
      <LineId Id="1080" Count="2" />
      <LineId Id="1108" Count="0" />
      <LineId Id="1112" Count="0" />
      <LineId Id="1109" Count="0" />
      <LineId Id="1111" Count="0" />
      <LineId Id="1113" Count="12" />
      <LineId Id="1110" Count="0" />
      <LineId Id="1083" Count="0" />
      <LineId Id="1071" Count="0" />
      <LineId Id="350" Count="3" />
      <LineId Id="917" Count="1" />
      <LineId Id="916" Count="0" />
      <LineId Id="993" Count="0" />
      <LineId Id="845" Count="0" />
      <LineId Id="1009" Count="2" />
      <LineId Id="1029" Count="0" />
      <LineId Id="1038" Count="1" />
      <LineId Id="1041" Count="0" />
      <LineId Id="1040" Count="0" />
      <LineId Id="1042" Count="0" />
      <LineId Id="1033" Count="2" />
      <LineId Id="1037" Count="0" />
      <LineId Id="1036" Count="0" />
      <LineId Id="1032" Count="0" />
      <LineId Id="846" Count="1" />
      <LineId Id="849" Count="0" />
      <LineId Id="848" Count="0" />
      <LineId Id="373" Count="1" />
      <LineId Id="794" Count="0" />
      <LineId Id="383" Count="0" />
      <LineId Id="920" Count="0" />
      <LineId Id="384" Count="0" />
      <LineId Id="927" Count="0" />
      <LineId Id="386" Count="1" />
      <LineId Id="842" Count="0" />
      <LineId Id="388" Count="0" />
      <LineId Id="796" Count="0" />
      <LineId Id="389" Count="6" />
      <LineId Id="1047" Count="0" />
      <LineId Id="396" Count="1" />
      <LineId Id="928" Count="1" />
      <LineId Id="398" Count="6" />
      <LineId Id="797" Count="0" />
      <LineId Id="407" Count="2" />
      <LineId Id="411" Count="7" />
      <LineId Id="930" Count="1" />
      <LineId Id="419" Count="2" />
      <LineId Id="798" Count="1" />
      <LineId Id="422" Count="8" />
      <LineId Id="932" Count="2" />
      <LineId Id="431" Count="1" />
      <LineId Id="936" Count="4" />
      <LineId Id="935" Count="0" />
      <LineId Id="941" Count="0" />
      <LineId Id="433" Count="0" />
      <LineId Id="437" Count="0" />
      <LineId Id="800" Count="0" />
      <LineId Id="438" Count="1" />
      <LineId Id="441" Count="0" />
      <LineId Id="801" Count="0" />
      <LineId Id="442" Count="16" />
      <LineId Id="802" Count="1" />
      <LineId Id="459" Count="12" />
      <LineId Id="804" Count="0" />
      <LineId Id="472" Count="4" />
      <LineId Id="805" Count="0" />
      <LineId Id="477" Count="9" />
      <LineId Id="489" Count="2" />
      <LineId Id="806" Count="1" />
      <LineId Id="492" Count="1" />
      <LineId Id="495" Count="13" />
      <LineId Id="942" Count="1" />
      <LineId Id="509" Count="1" />
      <LineId Id="808" Count="2" />
      <LineId Id="511" Count="8" />
      <LineId Id="944" Count="2" />
      <LineId Id="520" Count="2" />
      <LineId Id="811" Count="2" />
      <LineId Id="523" Count="8" />
      <LineId Id="947" Count="2" />
      <LineId Id="532" Count="1" />
      <LineId Id="951" Count="4" />
      <LineId Id="950" Count="0" />
      <LineId Id="956" Count="0" />
      <LineId Id="534" Count="0" />
      <LineId Id="538" Count="0" />
      <LineId Id="814" Count="0" />
      <LineId Id="539" Count="0" />
      <LineId Id="541" Count="0" />
      <LineId Id="815" Count="0" />
      <LineId Id="542" Count="8" />
      <LineId Id="957" Count="2" />
      <LineId Id="551" Count="0" />
      <LineId Id="816" Count="0" />
      <LineId Id="552" Count="8" />
      <LineId Id="960" Count="2" />
      <LineId Id="561" Count="1" />
      <LineId Id="964" Count="4" />
      <LineId Id="963" Count="0" />
      <LineId Id="969" Count="0" />
      <LineId Id="563" Count="0" />
      <LineId Id="567" Count="0" />
      <LineId Id="817" Count="0" />
      <LineId Id="568" Count="1" />
      <LineId Id="571" Count="0" />
      <LineId Id="980" Count="0" />
      <LineId Id="818" Count="0" />
      <LineId Id="572" Count="9" />
      <LineId Id="819" Count="0" />
      <LineId Id="582" Count="7" />
      <LineId Id="970" Count="2" />
      <LineId Id="590" Count="2" />
      <LineId Id="974" Count="4" />
      <LineId Id="973" Count="0" />
      <LineId Id="979" Count="0" />
      <LineId Id="593" Count="0" />
      <LineId Id="597" Count="1" />
      <LineId Id="820" Count="0" />
      <LineId Id="599" Count="3" />
      <LineId Id="981" Count="0" />
      <LineId Id="821" Count="0" />
      <LineId Id="603" Count="11" />
      <LineId Id="822" Count="1" />
      <LineId Id="615" Count="13" />
      <LineId Id="824" Count="1" />
      <LineId Id="629" Count="9" />
      <LineId Id="826" Count="1" />
      <LineId Id="639" Count="9" />
      <LineId Id="828" Count="1" />
      <LineId Id="649" Count="10" />
      <LineId Id="830" Count="1" />
      <LineId Id="660" Count="9" />
      <LineId Id="832" Count="1" />
      <LineId Id="670" Count="3" />
      <LineId Id="1127" Count="10" />
      <LineId Id="1126" Count="0" />
      <LineId Id="1139" Count="10" />
      <LineId Id="1138" Count="0" />
      <LineId Id="674" Count="5" />
      <LineId Id="834" Count="1" />
      <LineId Id="680" Count="9" />
      <LineId Id="836" Count="1" />
      <LineId Id="690" Count="9" />
      <LineId Id="838" Count="0" />
      <LineId Id="700" Count="17" />
      <LineId Id="839" Count="0" />
      <LineId Id="718" Count="5" />
      <LineId Id="840" Count="0" />
      <LineId Id="724" Count="6" />
      <LineId Id="1184" Count="0" />
      <LineId Id="732" Count="1" />
      <LineId Id="746" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_LoggingUndDiagnose">
      <LineId Id="13" Count="44" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_SchraubtaktMessung">
      <LineId Id="13" Count="7" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_StillstandsUeberwachung">
      <LineId Id="13" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_3_V01.m_TiefenPruefung">
      <LineId Id="17" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>