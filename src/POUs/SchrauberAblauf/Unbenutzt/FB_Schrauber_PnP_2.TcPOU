<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_Schrauber_PnP_2" Id="{30e4f978-b622-496f-a2ab-95b219a03b75}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Schrauber_PnP_2
(*
================================================================================
SERVOSCHRAUBER PICK-AND-PLACE - MÖBELINDUSTRIE
================================================================================
Beschreibung:	Vollautomatischer Servoschrauber für Schienen- und Einzelschrauben
				mit NC-Achsenanbindung, Drehmoment- und Tiefenüberwachung
				
Autor:			Überarbeitet für bessere Wartbarkeit und Übersichtlichkeit
Datum:			September 2025
Version:		2.0

ABLAUFBESCHREIBUNG:
===================
1. INITIALISIERUNG		(Step 0)    - Reset aller Ausgänge, Grundzustand
2. BEREITSCHAFT			(Step 10)   - Warten auf Startbedingungen
3. NACHLADEN			(Step 11-12)- Schraube aus Schlauch nachladen
4. SCHRAUBSTART			(Step 20)   - Vorbereitung Schraubvorgang
5. ZUSTELLUNG			(Step 30)   - Schraubhub ausfahren
6. AUFSETZEN			(Step 40)   - Auswurfhub bis Werkstück
7. ANLAUFPHASE			(Step 45)   - Langsame Drehzahl aufbauen
8. HAUPTSCHRAUBEN		(Step 50)   - Volldrehzahl erreichen
9. TIEFENPRÜFUNG		(Step 60)   - Solltiefe überwachen
10. DREHMOMENTPRÜFUNG	(Step 65)   - Sollmoment erreichen
11. MOTORSTOPP			(Step 70-75)- Kontrolliertes Stoppen
12. RÜCKFAHRT			(Step 80-85)- Zurück in Grundstellung
13. REFERENZIERUNG		(Step 90-95)- Achse referenzieren
14. ABSCHLUSS			(Step 100)  - Vorgang beendet
15. AUSWERFEN			(Step 200ff)- Schraube entfernen
16. FEHLERBEHANDLUNG	(Step -xx)  - Zentrale Fehlerbehandlung

SICHERHEITSFUNKTIONEN:
======================
- Watchdog-Timer für alle kritischen Schritte
- Überwachung von Schutzbereich und NC-Status
- Drehmomentbegrenzung und -überwachung
- Tiefentoleranzprüfung
- Automatische Fehlerquittierung (optional)
- Deterministische Zustandsmaschine
================================================================================
*)

VAR_INPUT
	(* === STEUERUNGSEINGÄNGE === *)
	I_bResetTeststation				: BOOL;		(* Test-Reset für Steuerungstechniker-Büro *)
	I_bTaktFrg						: BOOL;		(* Taktfreigabe vom übergeordneten System *)
	I_bTaktStop						: BOOL;		(* Taktstopp - stoppt aktuellen Vorgang *)
	I_bAuto							: BOOL;		(* Automatikbetrieb aktiv *)
	I_bHand							: BOOL;		(* Handbetrieb aktiv *)
	I_bQuittFehler					: BOOL;		(* Manuelle Fehlerquittierung *)
	I_bGrundstellung				: BOOL;		(* Anfahrt Grundstellung angefordert *)
	I_bSchutzbereichOK				: BOOL;		(* Schutzbereich ist frei *)

	(* === BESCHREIBUNGEN FÜR MELDUNGEN === *)
	I_sSourceBeschreibung			: STRING;	(* Quelle für Fehlermeldungen *)
	I_sPosBeschreibung				: STRING := 'Schrauber';	(* Positionsbeschreibung *)

	(* === PROZESSEINGÄNGE === *)
	I_bTaktStart					: BOOL;		(* Start für Vollschraubung (Schienenschrauben) *)
	I_bTaktStartHalb				: BOOL;		(* Start für Halbschraubung (z.B. Metalltraverse) *)
	I_bGrdstlgSchrEinh				: BOOL;		(* Schraubeinheit in Grundstellung *)
	I_bZustellZylAusgef				: BOOL;		(* Zustellzylinder ausgefahren (Endlage) *)

	(* === PROZESSPARAMETER === *)
	I_fSchraubTiefeAuswurf			: LREAL;	(* Auswurftiefe für Schraubenentfernung [mm] *)
	I_fTiefentoleranzPositiv		: LREAL := 1.0;		(* Positive Tiefentoleranz [mm] *)
	I_fTiefentoleranzNegativ		: LREAL := 0.5;		(* Negative Tiefentoleranz [mm] *)
	
	(* === ACHSENKONFIGURATION === *)
	I_nAchsId						: INT;		(* NC-Achsen-ID für Schraubmotor *)
	I_nEncId						: INT;		(* Encoder-ID für Tiefenmessung *)
	I_stParam						: ST_ParamSKSServoschrauber;	(* Prozessparameter *)

	(* === ERWEITERTE FUNKTIONEN === *)
	I_tAutoQuit						: TIME := T#0MS;	(* Automatische Quittierzeit (T#0MS = deaktiviert) *)
	I_bSchraubeNachschiessen		: BOOL;		(* Nachschießfunktion aktiv *)
	I_bReferenzfahrtAktiv			: BOOL;		(* Referenzfahrt läuft gerade *)
	I_bFreigabeAuswerfen			: BOOL;		(* Freigabe für Auswurfvorgang *)
	
	(* === LOGGING UND DIAGNOSE === *)
	I_sDateipfad					: STRING;	(* Pfad für Logdateien *)
	I_bSchrauberLogOn				: BOOL;		(* Schrauber-Abwahl (Log-Modus) *)
	I_nMotorHersteller				: INT;		(* 0=BRC, 1=Beckhoff *)
	I_bHuettenSchr					: BOOL := FALSE;	(* Hüttenhölscher/Boellhoff-Schrauber *)

END_VAR

VAR_OUTPUT
	(* === HAUPTAUSGÄNGE === *)
	Q_bBusy							: BOOL;		(* Schrauber arbeitet gerade *)
	Q_bDone							: BOOL;		(* Schraubvorgang erfolgreich beendet *)
	Q_bError						: BOOL;		(* Fehler aufgetreten *)

	(* === STATUSINFORMATIONEN === *)
	Q_sPosZustand					: STRING := '';		(* Aktueller Positionszustand *)
	Q_bGrundstellungAktiv			: BOOL;		(* Grundstellungsfahrt aktiv *)
	Q_bGrundstellungOk				: BOOL;		(* Grundstellung erreicht *)
	Q_sStatus						: STRING(255);		(* Detaillierte Statusmeldung *)

	(* === AKTORAUSGÄNGE === *)
	Q_bSchraubHub					: BOOL;		(* Schraubhub ausfahren *)
	Q_bSchrAuswurf					: BOOL;		(* Auswurfhub ausfahren *)
	Q_bSchrHalt						: BOOL;		(* Motor stoppen *)
	Q_nTorque						: INT := 300;		(* Drehmomentgrenzwert [0.1%] *)
	Q_bAxisReset					: BOOL;		(* Achse zurücksetzen *)

	(* === DIAGNOSEINFORMATIONEN === *)
	Q_nErrorId						: INT;		(* Eindeutige Fehler-ID *)
	Q_bDrehmomentFehler				: BOOL;		(* Drehmomentfehler aufgetreten *)
	Q_bTuerFreigabe					: BOOL;		(* Türfreigabe für Schutzeinrichtung *)
	Q_nStep							: INT;		(* Aktuelle Schrittnummer *)
	Q_strStep						: STRING;	(* Aktuelle Schrittbezeichnung *)
	Q_bModuloBetrArt				: BOOL;		(* Modulo-Betriebsart aktiv *)

END_VAR

VAR_IN_OUT
	(* === SCHNITTSTELLEN ZU ANDEREN BAUSTEINEN === *)
	IQ_fbObjSchlauch				: FB_Obj_IOSchlauch;		(* Schlauchsystem-Interface *)
	IQ_stMeldung					: ST_MeldServoSchrauber_1;	(* Meldungsstruktur *)
END_VAR

VAR
	(* === FEHLERVERWALTUNG === *)
	objError_Schrauber				: FB_Obj_Error_Schrauber;	(* Zentrale Fehlerverwaltung *)

	(* === INTERNE STEUERUNGSFLAGS === *)
	bSchrAuswurfStart				: BOOL;		(* Auswurfstart intern *)
	bSchraubHub						: BOOL;		(* Schraubhub intern *)
	bSchrAuswurf					: BOOL;		(* Auswurf intern *)
	bModuloBetrArt					: BOOL;		(* Modulo-Betrieb intern *)
	bReset							: BOOL;		(* Reset-Signal intern *)
	bAchsreset						: BOOL;		(* Achsen-Reset intern *)

	(* === PROZESSWERTE === *)
	fSchraubTiefeIst				: LREAL;	(* Aktuelle Schraubtiefe [mm] *)
	fDrehmomentIstMittel			: LREAL;	(* Gemitteltes Drehmoment [0.1%] *)
	nTiefeBeimAufsetzen				: LREAL;	(* Tiefe beim ersten Werkstückkontakt *)
	bTiefeBeimAufsetzenOK			: BOOL;		(* Aufsetzen korrekt erkannt *)

	(* === DREHMOMENT-MITTELWERTBILDUNG === *)
	arrDrehmomentIst				: ARRAY [0..10] OF LREAL;	(* Ringpuffer für Drehmoment *)
	idx								: INT;		(* Index für Array-Verarbeitung *)

	(* === TIMER UND ÜBERWACHUNG === *)
	tonAnlauf						: TON;		(* Anlauftimer *)
	tonStillstandAchse				: TON;		(* Achsen-Stillstandsüberwachung *)
	tonStillstandVorschub			: TON;		(* Vorschub-Stillstandsüberwachung *)
	tonStillstVorschubDelay			: TON;		(* Verzögerung Stillstandsüberwachung *)
	tonVerzStillstand				: TON;		(* Verzögerter Stillstand *)
	tonTimeOutSchrauber				: TON;		(* Watchdog Schraubvorgang *)
	tonAutoquit						: TON;		(* Timer für automatische Quittierung *)
	tonTimeOver1					: TON;		(* Universeller Timeout-Timer 1 *)
	tonDelay1						: TON;		(* Universeller Verzögerungstimer *)
	tonNotPosiFrg					: TON;		(* Timer für Positionierfreigabe *)
	tonSchraubtakt					: TON;		(* Timer für Schraubtakt-Messung *)

	(* === HILFSVARIABLEN FÜR ÜBERWACHUNG === *)
	fIstPosAchseAlt					: LREAL;	(* Vorherige Achsenposition *)
	fIstPosVorschubAlt				: LREAL;	(* Vorherige Vorschubposition *)
	bStillstandAchse				: BOOL;		(* Achse steht still *)
	bStillstandVorschub				: BOOL;		(* Vorschub steht still *)
	fReduzGeschwFaktor				: LREAL := 0.025;	(* Reduzierter Geschwindigkeitsfaktor *)

	(* === FEHLERBEHANDLUNG === *)
	nFehlerSchrittMerker			: INT;		(* Merker für Fehlerschritt *)
	nFehlerZaehler					: INT;		(* Zähler für aufgetretene Fehler *)

	(* === TRIGGER UND FLANKENAUSWERTUNG === *)
	rtrigReset						: R_TRIG;	(* Reset-Flanke *)
	ftrigStep60						: F_TRIG;	(* Fallende Flanke Step 60 *)
	rtrigStep70						: R_TRIG;	(* Steigende Flanke Step 70 *)
	ftrigStep70						: F_TRIG;	(* Fallende Flanke Step 70 *)
	rtrigStepError					: R_TRIG;	(* Steigende Flanke Fehler *)

	(* === AUTO-QUIT FUNKTIONALITÄT === *)
	bAutoquitAktiv					: BOOL;		(* Auto-Quit ist aktiv *)

	(* === ZUSTANDSMASCHINE === *)
	nStep							: INT;		(* Aktuelle Schrittnummer *)
	sStep							: STRING;	(* Aktuelle Schrittbezeichnung *)
	nOldStep						: INT;		(* Vorherige Schrittnummer *)
	nStepGrund						: INT;		(* Schritt Grundstellung *)
	nOldStepGrund					: INT;		(* Vorheriger Schritt Grundstellung *)
	tonTimeOverGrund				: TON;		(* Timeout Grundstellung *)

	(* === DIAGNOSE UND LOGGING === *)
	fbMittelwert					: FB_Mittelwert;			(* Mittelwertbildung *)
	fbStepHistory					: FB_StepHistory;			(* Schritthistorie *)
	fbLogToFile						: FB_LogFile_Schrauber;	(* Datei-Logging *)
	
	(* === STATISTISCHE AUSWERTUNG === *)
	timeSchraubtakt					: TIME;		(* Gemessene Schraubtaktzeit *)
	arrLetzteTiefe					: ARRAY[0..100] OF LREAL;	(* Historie Schraubtiefen *)
	arrLetzteFehler					: ARRAY[0..100] OF LREAL;	(* Historie Fehlercodes *)
	arrLetzteMomente				: ARRAY[0..100] OF LREAL;	(* Historie Drehmomente *)
	arrLetzteSchraubzeit			: ARRAY[0..100] OF TIME;	(* Historie Schraubzeiten *)
	rtrigStueckzaehler				: R_TRIG;	(* Trigger Stückzähler *)
	nStueckzaehler					: INT;		(* Stückzähler *)
	rtrigSchrauberfehler			: R_TRIG;	(* Trigger Schrauberfehler *)

	(* === SONDERPARAMETER === *)
	nAnzahlSchraubspitzenKlemmer	: DINT;		(* Zähler für Schraubspitzenklemmer *)
	fSchraubTiefeIstTest			: LREAL;	(* Test-Schraubtiefe *)

	(* === TEST- UND DEBUG-VARIABLEN === *)
	bSchraubtest					: BOOL;		(* Testmodus aktiv *)
	nTestmoment						: UINT := 320;		(* Test-Drehmoment *)
	nTestStep1						: INT;		(* Debug-Zähler 1 - UNGENUTZT *)
	nTestStep2						: INT;		(* Debug-Zähler 2 - UNGENUTZT *)
	nTestStep3						: INT;		(* Debug-Zähler 3 - UNGENUTZT *)

END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
================================================================================
HAUPTPROGRAMM SERVOSCHRAUBER
================================================================================
Aufruffolge der Methoden:
1. Reset-Behandlung
2. Hauptablauf (Zustandsmaschine)
3. Fehlerbehandlung
4. Logging und Diagnose
5. Ausgangszuweisung
================================================================================
*)

// === RESET-BEHANDLUNG ===
m_HandleReset();

// === HAUPTABLAUF (ZUSTANDSMASCHINE) ===
m_Hauptablauf();

// === FEHLERBEHANDLUNG ===
m_Fehlerbehandlung();

// === LOGGING UND DIAGNOSE ===
m_LoggingUndDiagnose();

// === AUSGANGSZUWEISUNG ===
m_Ausgangszuweisung();

// === KONSTANTEN ===
fReduzGeschwFaktor := 0.005;	(* Reduzierter Geschwindigkeitsfaktor für Feineinstellung *)]]></ST>
    </Implementation>
    <Method Name="m_Ausgangszuweisung" Id="{23e67497-dcf5-4300-9056-2e4f31a9eebc}">
      <Declaration><![CDATA[METHOD m_Ausgangszuweisung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
AUSGANGSZUWEISUNG
================================================================================
Zentrale Zuweisung aller Ausgangssignale mit Sicherheitsverriegelung
durch Schutzbereich und Reset-Zustand
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === SCHLAUCHSYSTEM-STEUERUNG ===
IQ_fbObjSchlauch.I_bSotiertopfEin := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND (nStep = 11 
	OR nStep = 21);

IQ_fbObjSchlauch.I_bFrgNachladen := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND (nStep = 11);

// === PNEUMATIK-AUSGÄNGE ===
Q_bSchraubHub := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND bSchraubHub;

Q_bSchrAuswurf := 
	I_bSchutzbereichOK 
	AND NOT bReset 
	AND bSchrAuswurf;

// === HAUPTSTATUS-AUSGÄNGE ===
Q_bBusy		:= (nStep <> 10);		(* Beschäftigt wenn nicht in Bereitschaft *)
Q_bDone		:= (nStep = 100);		(* Fertig bei Schritt 100 *)
Q_bSchrHalt	:= (nStep = 70);		(* Motor-Halt bei Schritt 70 *)

// === ACHSEN-STEUERUNG ===
Q_bAxisReset := bAchsreset;

// === SICHERHEITS-AUSGÄNGE ===
Q_bTuerFreigabe := (nStep <= 10);	(* Türfreigabe nur in Grundzustand *)

// === DIAGNOSE-AUSGÄNGE ===
Q_nStep 	:= nStep;
Q_strStep	:= sStep;
Q_sStatus	:= CONCAT(INT_TO_STRING(nStep), CONCAT(' - ', sStep));

// === MODULO-BETRIEBSART ===
Q_bModuloBetrArt := bModuloBetrArt;]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DiagnoseHistorie" Id="{70018bdd-0219-4b0e-965f-4117e0e589df}">
      <Declaration><![CDATA[METHOD m_DiagnoseHistorie : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
DIAGNOSE-HISTORIE
================================================================================
Speichert die letzten 100 Schraubvorgänge mit allen wichtigen Parametern
für Qualitätssicherung und Fehleranalyse.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === FLANKENAUSWERTUNG FÜR SCHRAUBENDE ===
ftrigStep70(CLK := nStep = 70);
rtrigStep70(CLK := nStep = 70);

// === DATEN IN HISTORIE SPEICHERN ===
IF rtrigStep70.Q 
THEN
	// Alle Arrays nach rechts verschieben
	FOR idx := 100 TO 1 BY -1 DO
		arrLetzteTiefe[idx] 		:= arrLetzteTiefe[idx-1];
		arrLetzteFehler[idx] 		:= arrLetzteFehler[idx-1];
		arrLetzteMomente[idx] 		:= arrLetzteMomente[idx-1];
		arrLetzteSchraubzeit[idx] 	:= arrLetzteSchraubzeit[idx-1];
	END_FOR
	
	// Aktuelle Werte speichern
	arrLetzteTiefe[0] 		:= fSchraubTiefeIst;
	arrLetzteFehler[0] 		:= nFehlerSchrittMerker;
	arrLetzteMomente[0] 	:= fDrehmomentIstMittel;
	arrLetzteSchraubzeit[0] := timeSchraubtakt;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentMittelwert" Id="{fcbf7618-4618-48ed-9202-dd017da5359b}">
      <Declaration><![CDATA[METHOD m_DrehmomentMittelwert : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
DREHMOMENT-MITTELWERTBILDUNG
================================================================================
Berechnet den gleitenden Mittelwert des Drehmoments über 10 Werte
zur Vermeidung von Fehlauslösungen durch kurze Spitzen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === MITTELWERTBILDUNG NUR WÄHREND DREHMOMENTPRÜFUNG ===
IF nStep >= 65 
	AND nStep <= 70 
THEN
	// Aktuellen Wert in Array einfügen
	arrDrehmomentIst[0] := ABS(arrNcAchsen[I_nAchsId].stEinAusG.I_nDrehmomentIstwert);
	
	// Array nach rechts verschieben (Ringpuffer)
	FOR idx := 10 TO 1 BY -1 DO
		arrDrehmomentIst[idx] := arrDrehmomentIst[idx-1];
	END_FOR
	
	// Mittelwert über alle 10 Werte berechnen
	fDrehmomentIstMittel := (arrDrehmomentIst[1] 
						   + arrDrehmomentIst[2] 
						   + arrDrehmomentIst[3] 
						   + arrDrehmomentIst[4] 
						   + arrDrehmomentIst[5] 
						   + arrDrehmomentIst[6] 
						   + arrDrehmomentIst[7] 
						   + arrDrehmomentIst[8] 
						   + arrDrehmomentIst[9] 
						   + arrDrehmomentIst[10]) / 10;
ELSE
	fDrehmomentIstMittel := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Fehlerbehandlung" Id="{e73674cc-a8d4-433b-ab13-83c1a484b510}">
      <Declaration><![CDATA[METHOD m_Fehlerbehandlung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
ZENTRALE FEHLERBEHANDLUNG
================================================================================
Verwaltet alle Fehlerzustände und erstellt entsprechende Meldungen.
Jeder Fehler hat eine eindeutige ID und eine klare Beschreibung.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === EINZELFEHLER-BEHANDLUNG ===

// Fehler -40: Schraube fehlt beim Nachladen
objError_Schrauber.I_fbFehlerNachladen(
	I_bAktiv := (nStep = -40));

// Fehler -45: Langsame Geschwindigkeit wird nicht erreicht
objError_Schrauber.I_fbFehlerLangsameGeschwindigkeit(
	I_bAktiv := (nStep = -45));

// Fehler -50: Schraubtiefe für Solldrehzahl wird nicht erreicht
objError_Schrauber.I_fbFehlerTiefeSolldrehzahl(
	I_bAktiv := (nStep = -50));

// Fehler -60: Solltiefe nicht erreicht
objError_Schrauber.I_fbFehler_Tiefe(
	I_bAktiv := (nStep = -60));

// Fehler -61: Solltiefe überschritten
objError_Schrauber.I_fbFehler_TiefeUeberschritten(
	I_bAktiv := (nStep = -61));

// Fehler -65: Solldrehmoment nicht erreicht
objError_Schrauber.I_fbFehler_Sollmoment(
	I_bAktiv := (nStep = -65));

// Fehler -80: Fehler beim Heben/Senken der Schrauberstange
objError_Schrauber.I_fbFehler_Schrauberstange(
	I_bAktiv := (nStep = -80));

// Fehler -210: Fehler beim Auswerfen
objError_Schrauber.I_fbFehlerAuswurf(
	I_bAktiv := (nStep = -210));

// === ALLGEMEINE FEHLERANZEIGE ===
Q_bError := (nStep < 0) AND NOT I_bSchrauberLogOn;

// === MELDUNGSSTRUKTUR AKTUALISIEREN ===
IQ_stMeldung.bMeldFehlNachladen 				:= objError_Schrauber.I_fbFehlerNachladen.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlLangsameGeschwindigkeit 	:= objError_Schrauber.I_fbFehlerLangsameGeschwindigkeit.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlTiefeSolldrehzahl 		:= objError_Schrauber.I_fbFehlerTiefeSolldrehzahl.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSollTiefe 				:= objError_Schrauber.I_fbFehler_Tiefe.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSollTiefeUebers 			:= objError_Schrauber.I_fbFehler_TiefeUeberschritten.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSollDrehmom 				:= objError_Schrauber.I_fbFehler_Sollmoment.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlSchrauberstange 			:= objError_Schrauber.I_fbFehler_Schrauberstange.I_bAktiv 
													AND NOT I_bSchrauberLogOn;
IQ_stMeldung.bMeldFehlAuswerfen 				:= objError_Schrauber.I_fbFehlerAuswurf.I_bAktiv 
													AND NOT I_bSchrauberLogOn;

// === MELDUNGSIDENTIFIKATION ===
IQ_stMeldung.sName 		:= I_sPosBeschreibung;
IQ_stMeldung.SourceName := I_sSourceBeschreibung;]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_HandleReset" Id="{26e85bcd-17e0-4097-8f09-a2eb1296b3cd}">
      <Declaration><![CDATA[METHOD m_HandleReset : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
RESET-BEHANDLUNG
================================================================================
Zentrale Behandlung aller Reset-Bedingungen.
Reset ist möglich über:
- Nachschüttel-Taste (wenn nicht in kritischen Schritten)
- Test-Reset für Steuerungstechniker
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === RESET-FLANKENAUSWERTUNG ===
rtrigReset(CLK := IQ_fbObjSchlauch.I_bTasteNachruetteln);

// === RESET-BEDINGUNGEN ===
bReset := rtrigReset.Q 
		AND NOT (nStep = 10 
		OR nStep = 90)	(* Nicht in kritischen Schritten *)
		OR I_bResetTeststation;				(* Test-Reset für Steuerungstechniker *)]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_Hauptablauf" Id="{fd43f060-d55e-42b2-a1ab-50254124ba95}">
      <Declaration><![CDATA[METHOD m_Hauptablauf : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
HAUPTABLAUF - ZUSTANDSMASCHINE SERVOSCHRAUBER
================================================================================
Zentrale Zustandsmaschine mit deterministischem Ablauf.
Alle Schritte sind eindeutig nummeriert und kommentiert.
Watchdog-Timer überwachen kritische Phasen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === HAUPTZUSTANDSMASCHINE ===
IF NOT bReset 
THEN
	CASE nStep OF
	
	// ================================================================================
	// INITIALISIERUNG UND BEREITSCHAFT
	// ================================================================================
	
	0: (* === INITIALISIERUNG === *)
		sStep := 'Initialisierung';
		
		// Alle Ausgänge zurücksetzen
		bSchraubHub 		:= FALSE;
		bSchrAuswurf 		:= FALSE;
		bAutoquitAktiv 		:= FALSE;
		bSchraubtest 		:= FALSE;
		bModuloBetrArt 		:= FALSE;
		
		// NC-Achse initialisieren
		arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := FALSE;
		tonNotPosiFrg(IN := FALSE);
		
		// Übergang zur Bereitschaft
		IF I_bTaktFrg 
			AND NOT I_bGrundstellung 
		THEN
			nStep := 10;
		END_IF

	10: (* === BEREITSCHAFT === *)
		sStep := 'Bereitschaft';
		
		// Fehlermerker zurücksetzen
		nFehlerSchrittMerker := 0;
		bTiefeBeimAufsetzenOK := FALSE;
		bModuloBetrArt := TRUE;
		
		// Watchdog für NC-Positionierung
		tonNotPosiFrg(
			IN := (NOT arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg
				   AND arrNcAchsen[I_nAchsId].stEinAusG.I_nDCStatusword.13)
				  OR arrNcAchsen[I_nAchsId].bNcFehler,
			PT := T#10S);
		
		// Achsen-Reset bei NC-Fehler
		bAchsreset := tonNotPosiFrg.Q 
						AND bTakt2langsam;
		
		// NC-Achse für normalen Betrieb konfigurieren
		IF NOT I_bReferenzfahrtAktiv 
		THEN
			arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := FALSE;
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := FALSE;
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;
		END_IF
		
		// Schrauber freigeben nach Nachschießen
		IF I_bSchraubeNachschiessen 
		THEN
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
		END_IF
		
		// === BETRIEBSARTEN-AUSWAHL ===
		
		// AUSWERFEN: Manuelle Schraubenentfernung
		IF (bSchrAuswurfStart 
			OR IQ_fbObjSchlauch.I_bSchrAuswurfStart 
		    OR IQ_fbObjSchlauch.I_bTasteVereinzelung) 
		   AND NOT I_bTaktStop 
		THEN
			IQ_fbObjSchlauch.I_bSchrAuswurfStart := FALSE;
			bSchrAuswurfStart := FALSE;
			tonTimeOver1(IN := FALSE);
			nStep := 200;	(* -> Auswurfsequenz *)
			bAchsreset := FALSE;
		
		// NACHLADEN: Schraube aus Schlauch nachladen
		ELSIF NOT IQ_fbObjSchlauch.I_bSchrauberBelegt 
			  AND IQ_fbObjSchlauch.I_bSchlauchBelegt 
			  AND NOT I_bQuittFehler 
			  AND NOT I_bTaktStop 
		THEN
			
			IF I_bHuettenSchr 
			THEN
				// Sonderbehandlung für Hüttenhölscher-Schrauber
				tonTimeOver1(IN := TRUE, PT := T#0MS);
				bSchrAuswurf := FALSE;
				
				IF tonTimeOver1.Q
				THEN
					tonTimeOver1(IN := FALSE);
					nStep := 11;	(* -> Nachladen *)
				END_IF
			ELSE
				bSchrAuswurf := TRUE;
				nStep := 11;		(* -> Nachladen *)
			END_IF
			bAchsreset := FALSE;
		
		// VOLLSCHRAUBUNG: Schienenschrauben komplett einschrauben
		ELSIF IQ_fbObjSchlauch.I_bSchrauberBelegt 
			  AND I_bTaktStart 
			  AND NOT I_bTaktStop 
			  AND NOT I_bTaktStartHalb 
			  AND arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg 
			  AND I_bTaktFrg 
			  AND NOT I_bQuittFehler 
			  OR bSchraubtest 
		THEN
			
			// NC-Achse für Schraubvorgang konfigurieren
			arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := TRUE;
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := TRUE;
			arrNcAchsen[I_nAchsId].stGrdfkt.fIstSetzwert := 0;
			Q_nTorque := 3000;
			Q_bDrehmomentFehler := FALSE;
			
			bAchsreset := FALSE;
			nStep := 20;	(* -> Schraubstart *)
		
		// HALBSCHRAUBUNG: Schraube nur teilweise einschrauben (z.B. Metalltraverse)
		ELSIF IQ_fbObjSchlauch.I_bSchrauberBelegt 
			  AND NOT I_bTaktStart 
			  AND I_bTaktStartHalb 
			  AND NOT I_bTaktStop 
			  AND arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg 
			  AND I_bTaktFrg 
			  AND NOT I_bQuittFehler 
		THEN
			
			// NC-Achse für Halbschraubung konfigurieren
			arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := TRUE;
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := TRUE;
			arrNcAchsen[I_nAchsId].stGrdfkt.fIstSetzwert := 0;
			Q_nTorque := 3000;
			
			// Testmoment für Diagnose
			IF bSchraubtest 
			THEN
				Q_nTorque := nTestmoment;
			END_IF
			
			bAchsreset := FALSE;
			nStep := 20;	(* -> Schraubstart *)
		END_IF

	// ================================================================================
	// NACHLADESEQUENZ
	// ================================================================================
	
	11: (* === NACHLADEN AKTIV === *)
		sStep := 'Nachladen_Aktiv';
		
		// Warten bis Schrauber belegt oder manuelle Vereinzelung
		IF (IQ_fbObjSchlauch.I_bSchrauberBelegt 
		    OR IQ_fbObjSchlauch.I_bTasteVereinzelung) 
		   AND NOT IQ_fbObjSchlauch.I_bNachladenaktiv 
		THEN
			bSchrAuswurf := FALSE;
			tonTimeOver1(IN := FALSE);
			nStep := 12;
		END_IF

	12: (* === NACHLADEN ABWARTEN === *)
		sStep := 'Nachladen_Wartepause';
		
		// Kurze Wartepause nach Nachladen
		tonTimeOver1(IN := TRUE, PT := T#200MS);
		
		IF tonTimeOver1.Q 
		THEN
			bSchrAuswurf := FALSE;
			nStep := 10;	(* -> Zurück zur Bereitschaft *)
		END_IF

	// ================================================================================
	// SCHRAUBSEQUENZ
	// ================================================================================
	
	20: (* === SCHRAUBSTART VORBEREITUNG === *)
		sStep := 'Schraubstart_Vorbereitung';
		
		// Warten auf alle Startbedingungen
		IF IQ_fbObjSchlauch.I_bSchrauberBelegt 
		   AND (I_bTaktStart 
			OR I_bTaktStartHalb) 
		   AND I_bTaktFrg 
		   AND NOT I_bQuittFehler 
		   OR bSchraubtest 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 30;	(* -> Zustellung *)
		END_IF

	30: (* === SCHRAUBHUB AUSFAHREN === *)
		sStep := 'Schraubhub_Ausfahren';
		
		// Watchdog für Zustellvorgang
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdZustellhubSchr);
		bSchraubHub := TRUE;
		
		// Warten auf Zustellung oder Endlage
		IF I_bTaktFrg 
			AND (tonTimeOver1.Q 
			OR I_bZustellZylAusgef) 
		THEN
			tonTimeOver1(IN := FALSE);
			tonTimeOutSchrauber(IN := FALSE);
			nStep := 40;	(* -> Aufsetzen *)
		END_IF

	40: (* === AUFSETZVORGANG === *)
		sStep := 'Aufsetzen_auf_Werkstueck';
		
		// Watchdog für Aufsetzvorgang
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdSchraubhubSchr);
		tonTimeOutSchrauber(IN := TRUE, PT := I_stParam.tParam_ZeitdSchraubhubSchr + T#2S);
		
		// Tiefe beim ersten Kontakt merken
		nTiefeBeimAufsetzen := fSchraubTiefeIst;
		bSchrAuswurf := TRUE;
		
		// Prüfung der Aufsetztiefe
		IF F_Inbetween(
			I_fActualValue := nTiefeBeimAufsetzen,
			I_fMinimalValue := 10 - 5,		(* Sollaufsetztiefe ± Toleranz *)
			I_fMaximalValue := 10 + 5) 
		THEN
			bTiefeBeimAufsetzenOK := TRUE;
		END_IF
		
		// Fehlerbehandlung: Schraube fehlt
		IF tonTimeOver1.Q 
			AND I_bTaktFrg 
			AND NOT bSchraubtest 
		   	AND F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := I_stParam.fParam_Sollschraubtiefe - 100,
			I_fMaximalValue := I_stParam.fParam_Sollschraubtiefe) 
		THEN
			
			// Schraubvorgang abbrechen - Schraube fehlt
			tonTimeOver1(IN := FALSE);
			bSchraubHub := FALSE;
			bSchrAuswurf := FALSE;
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := FALSE;
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
			nFehlerZaehler := nFehlerZaehler + 1;
			nStep := -40;	(* -> Fehler: Schraube fehlt *)
		
		// Übergang zur Anlaufphase
		ELSIF tonTimeOver1.Q 
			AND I_bTaktFrg 
			AND arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_gesetz
			AND arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg 
			AND ((fSchraubTiefeIst <= 15) 
			OR tonTimeOutSchrauber.Q) 
		THEN
			
			// Statistik für Schraubspitzenklemmer
			IF tonTimeOutSchrauber.Q 
			THEN
				nAnzahlSchraubspitzenKlemmer := nAnzahlSchraubspitzenKlemmer + 1;
			END_IF
			
			tonTimeOutSchrauber(IN := FALSE);
			tonTimeOver1(IN := FALSE);
			arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz := FALSE;
			nStep := 45;	(* -> Anlaufphase *)
		END_IF

	45: (* === ANLAUFPHASE - LANGSAME DREHZAHL === *)
		sStep := 'Anlaufphase_Langsam';
		
		// Watchdog für Anlaufphase
		tonTimeOver1(IN := TRUE, PT := T#5S);
		
		// Startdrehzahl setzen
		arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fStartDrehzahl;
		arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode := MC_Aborting;
		arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;
		
		// Prüfung ob 80% der Sollgeschwindigkeit erreicht
		IF (arrNcAchsen[I_nAchsId].stStatus.bFaehrtPos 
		    AND ((arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw * 0.8) 
			     > (arrNcAchsen[I_nAchsId].fVeloIstwert 
				    / arrNcAchsen[I_nAchsId].stParam.fEilgGeschw * 100))) 
		THEN
			
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;
			tonTimeOver1(IN := FALSE);
			nStep := 50;	(* -> Hauptschraubphase *)
			
		ELSIF tonTimeOver1.Q 
		THEN
			// Timeout - Geschwindigkeit nicht erreicht
			tonTimeOver1(IN := FALSE);
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -45;	(* Fehlercode merken *)
		END_IF

	50: (* === HAUPTSCHRAUBPHASE - GESCHWINDIGKEIT AUFBAUEN === *)
		sStep := 'Hauptschraubphase_Beschleunigen';
		
		// Watchdog für Beschleunigungsphase
		tonTimeOver1(IN := TRUE, PT := T#3S);
		arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;
		
		// Umschaltung auf Solldrehzahl basierend auf Schraubtiefe
		IF I_bTaktStart 
			AND fSchraubTiefeIst < I_stParam.fSchraubTiefeSollDrehzahl 
		THEN
			// Vollschraubung
			arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fParam_Solldrehzahl;
			arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode := MC_BlendingNext;
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;
			nStep := 60;	(* -> Tiefenprüfung *)
			
		ELSIF I_bTaktStartHalb 
		THEN
			// Halbschraubung
			arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fParam_Solldrehzahl * 0.5;
			arrNcAchsen[I_nAchsId].stAuftrg.ePTP_BuffMode := MC_BlendingNext;
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;
			nStep := 60;	(* -> Tiefenprüfung *)
			
		ELSIF tonTimeOver1.Q 
		THEN
			// Timeout - Solltiefe für Drehzahlumschaltung nicht erreicht
			tonTimeOver1(IN := FALSE);
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -50;	(* Fehlercode merken *)
		END_IF

	60: (* === TIEFENPRÜFUNG === *)
		sStep := 'Tiefenpruefung_Solltiefe';
		
		// Watchdog für Schraubvorgang
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdSchraubTakt);
		arrStartAusf[I_nAchsId].I_bAchseZurArbP := I_bTaktFrg;
		
		// Mittelwertbildung zurücksetzen
		fbMittelwert(I_bReset := TRUE);
		
		// Prüfung Solltiefe erreicht
		IF (F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := -10,
			I_fMaximalValue := I_stParam.fParam_Sollschraubtiefe) 
		    AND I_bTaktStart) 
		   	OR (F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := 0,
			I_fMaximalValue := I_stParam.fParam_SollschraubtiefeHerdumbau) 
		     AND I_bTaktStartHalb) 
		THEN
			
			// Drehzahl für Feineinstellung reduzieren
			arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw := I_stParam.fParam_Solldrehzahl * 0.12;
			nStep := 65;	(* -> Drehmomentprüfung *)
			tonTimeOver1(IN := FALSE);
		END_IF
		
		// Timeout - Solltiefe nicht erreicht
		tonTimeOver1(IN := TRUE, PT := T#3000MS);
		IF tonTimeOver1.Q 
			AND tonDelay1.ET > T#3000MS 
		THEN
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -60;	(* Fehlercode merken *)
			tonTimeOver1(IN := FALSE);
		END_IF

	65: (* === DREHMOMENTPRÜFUNG === *)
		sStep := 'Drehmomentpruefung_Sollmoment';
		
		// Mittelwertbildung für Drehmoment
		fbMittelwert(
			I_bReset := FALSE,
			I_fAktlWert := ABS(arrNcAchsen[I_nAchsId].stEinAusG.I_nDrehmomentIstwert),
			I_nAnzWerte := 10);
		
		// Vollschraubung: Sollmoment erreicht
		IF fDrehmomentIstMittel >= 
			I_stParam.fParam_Sollmoment * 100 * 1.1 
		   AND I_bTaktStart 
		THEN
			nStep := 70;	(* -> Motor stoppen *)
		END_IF
		
		// Halbschraubung: Reduziertes Moment erreicht
		IF fDrehmomentIstMittel >= 
			I_stParam.fParam_Sollmoment * 100 * 0.1 
		   AND I_bTaktStartHalb 
		THEN
			nTestStep3 := nTestStep3 + 1;	(* Debug-Zähler *)
			nStep := 70;	(* -> Motor stoppen *)
		END_IF
		
		// Timeout-Behandlung
		IF tonDelay1.ET > I_stParam.tParam_ZeitdSchraubTakt 
		THEN
			IF fbMittelwert.Q_fMittelwert >= (I_stParam.fParam_Sollmoment * 100 / 5) 
			THEN
				nTestStep1 := nTestStep1 + 1;	(* Debug-Zähler *)
				nStep := 70;	(* -> Motor stoppen *)
				nFehlerSchrittMerker := -65;	(* Fehlercode merken *)
			ELSE
				nTestStep2 := nTestStep2 + 1;	(* Debug-Zähler *)
				nStep := 70;	(* -> Motor stoppen *)
				nFehlerSchrittMerker := -65;	(* Fehlercode merken *)
			END_IF
		END_IF
		
		// Spezialfall: Tiefe überschritten ohne korrektes Aufsetzen
		IF fSchraubTiefeIst <= I_stParam.fParam_Sollschraubtiefe - 10 
		   AND NOT bTiefeBeimAufsetzenOK 
		THEN
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -61;	(* Fehlercode merken *)
		END_IF

	70: (* === MOTOR STOPPEN === *)
		sStep := 'Motor_Stoppen';
		
		// Watchdog für Stoppvorgang
		tonTimeOver1(IN := TRUE, PT := T#1000MS);
		
		// Achse stoppen
		arrStartAusf[I_nAchsId].I_bAchseStopPos := TRUE;
		
		// Warten auf Stillstand
		IF tonTimeOver1.Q 
		   OR arrStartAusf[I_nAchsId].Q_bAchseGestPos 
		   OR arrStartAusf[I_nAchsId].Q_bAchseInPos
		THEN
			
			tonTimeOver1(IN := FALSE);
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
			Q_nTorque := 0;
			nStep := 75;	(* -> Stillstand abwarten *)
		END_IF

	75: (* === STILLSTAND ABWARTEN === *)
		sStep := 'Stillstand_Abwarten';
		
		// Watchdog für Stillstand
		tonTimeOver1(IN := TRUE, PT := T#2000MS);
		
		// Warten auf Motorstillstand
		IF tonTimeOver1.Q 
			OR arrNcAchsen[I_nAchsId].stStatus.bInStillst 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 80;	(* -> Rückfahrt vorbereiten *)
		END_IF

	80: (* === RÜCKFAHRT VORBEREITEN === *)
		sStep := 'Rueckfahrt_Vorbereiten';
		
		// Watchdog für Rückfahrt
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdAuswurfSchr);
		bSchrAuswurf := FALSE;
		
		// Prüfung ob Rückfahrposition erreicht
		IF F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := 80 - 10,
			I_fMaximalValue := 80 + 10) 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 85;	(* -> Schraubhub einfahren *)
			
		ELSIF tonTimeOver1.Q 
		THEN
			tonTimeOver1(IN := FALSE);
			bSchraubHub := FALSE;
			nStep := 90;	(* -> Grundstellung *)
			nFehlerSchrittMerker := -80;	(* Fehlercode merken *)
		END_IF

	85: (* === SCHRAUBHUB EINFAHREN === *)
		sStep := 'Schraubhub_Einfahren';
		
		bSchraubHub := FALSE;
		nStep := 90;	(* -> Grundstellung *)

	90: (* === GRUNDSTELLUNG ANFAHREN === *)
		sStep := 'Grundstellung_Anfahren';
		
		// Warten auf Grundstellung
		IF I_bGrdstlgSchrEinh 
			AND I_bTaktFrg 
		THEN
			arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.2 := TRUE;	(* Referenzierung *)
			bAchsreset := TRUE;
			nStep := 95;	(* -> Referenzierung *)
		END_IF

	95: (* === ACHSE REFERENZIEREN === *)
		sStep := 'Achse_Referenzieren';
		
		bAchsreset := FALSE;
		
		// Warten auf Referenzierung
		IF arrNcAchsen[I_nAchsId].stEinAusG.I_nSignalstatuswort.0 
		   OR I_nMotorHersteller = 1 
		THEN
			
			arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.2 := FALSE;
			
			// Fehlerbehandlung oder erfolgreich beenden
			IF nFehlerSchrittMerker <> 0 
			THEN
				nFehlerZaehler := nFehlerZaehler + 1;
				nStep := nFehlerSchrittMerker;	(* -> Fehlerbehandlung *)
				nFehlerSchrittMerker := 0;
			ELSE
				nStep := 100;	(* -> Erfolgreich beendet *)
			END_IF
		END_IF

	100: (* === VORGANG ERFOLGREICH BEENDET === *)
		sStep := 'Vorgang_Beendet';
		
		bSchraubtest := FALSE;
		
		// Warten auf Freigabe für nächsten Zyklus
		IF NOT I_bTaktStart 
			AND NOT I_bTaktStartHalb
		THEN
			Q_nTorque := 300;
			bAutoquitAktiv := FALSE;
			bSchraubtest := FALSE;
			arrNcAchsen[I_nAchsId].stEinAusG.Q_nSignalsteuerwort.1 := FALSE;
			arrStartAusf[I_nAchsId].I_bAchseZurArbP := FALSE;
			nStep := 10;	(* -> Zurück zur Bereitschaft *)
		END_IF

	// ================================================================================
	// AUSWURFSEQUENZ
	// ================================================================================
	
	200: (* === AUSWURF START === *)
		sStep := 'Auswurf_Start';
		
		// Watchdog für Auswurf-Freigabe
		tonTimeOver1(IN := TRUE, PT := T#10S);
		
		IF I_bTaktFrg 
			AND I_bFreigabeAuswerfen 
			OR tonTimeOver1.Q 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 205;	(* -> Auswurf Zustellung *)
		END_IF

	205: (* === AUSWURF ZUSTELLUNG === *)
		sStep := 'Auswurf_Zustellung';
		
		// Watchdog für Zustellung
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdZustellhubSchr);
		bSchraubHub := TRUE;
		
		IF I_bTaktFrg 
			AND (tonTimeOver1.Q 
			OR I_bZustellZylAusgef) 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 210;	(* -> Auswurf ausfahren *)
		END_IF

	210: (* === AUSWURF AUSFAHREN === *)
		sStep := 'Auswurf_Ausfahren';
		
		// Watchdog für Auswurfvorgang
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdAuswurfSchr);
		bSchrAuswurf := TRUE;
		
		// Prüfung Auswurfposition erreicht
		IF F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := I_fSchraubTiefeAuswurf - 100,
			I_fMaximalValue := I_fSchraubTiefeAuswurf + 1) 
		THEN
			nStep := 230;	(* -> Auswurf aktiv *)
			
		ELSIF tonTimeOver1.Q
		THEN
			tonTimeOver1(IN := FALSE, PT := T#500MS);
			bSchrAuswurf := FALSE;
			nStep := 215;	(* -> Wiederholungsversuch *)
		END_IF

	215: (* === AUSWURF PAUSE === *)
		sStep := 'Auswurf_Pause';
		
		tonTimeOver1(IN := TRUE, PT := T#100MS);
		IF tonTimeOver1.Q 
		THEN
			tonTimeOver1(IN := FALSE);
			nStep := 220;	(* -> Auswurf wiederholen *)
		END_IF

	220: (* === AUSWURF WIEDERHOLEN === *)
		sStep := 'Auswurf_Wiederholen';
		
		// Watchdog für Wiederholungsversuch
		tonTimeOver1(IN := TRUE, PT := I_stParam.tParam_ZeitdAuswurfSchr);
		bSchrAuswurf := TRUE;
		
		// Prüfung Auswurfposition erreicht
		IF F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := I_fSchraubTiefeAuswurf - 100,
			I_fMaximalValue := I_fSchraubTiefeAuswurf + 1) 
		THEN
			nStep := 230;	(* -> Auswurf aktiv *)
			tonTimeOver1(IN := FALSE, PT := T#500MS);
			
		ELSIF tonTimeOver1.Q 
		THEN
			bSchrAuswurf := FALSE;
			bSchraubHub := FALSE;
			nStep := -210;	(* -> Fehler Auswurf *)
			tonTimeOver1(IN := FALSE, PT := T#500MS);
		END_IF

	230: (* === AUSWURF AKTIV === *)
		sStep := 'Auswurf_Aktiv';
		
		IF I_bTaktFrg 
		THEN
			nStep := 240;	(* -> Auswurf zurückfahren *)
		END_IF

	240: (* === AUSWURF ZURÜCKFAHREN === *)
		sStep := 'Auswurf_Zurueckfahren';
		
		// Watchdog für Rückfahrt
		tonTimeOver1(IN := TRUE, PT := T#1000MS);
		bSchrAuswurf := FALSE;
		bSchraubHub := FALSE;
		
		// Prüfung Ausgangsposition erreicht
		IF NOT F_Inbetween(
			I_fActualValue := fSchraubTiefeIst,
			I_fMinimalValue := I_fSchraubTiefeAuswurf - 100,
			I_fMaximalValue := I_fSchraubTiefeAuswurf + 1) 
		   AND NOT I_bZustellZylAusgef 
		THEN
			nStep := 250;	(* -> Auswurf beendet *)
			tonTimeOver1(IN := FALSE, PT := T#1000MS);
			
		ELSIF tonTimeOver1.Q 
		THEN
			bSchrAuswurf := FALSE;
			bSchraubHub := FALSE;
			nStep := -210;	(* -> Fehler Auswurf *)
			tonTimeOver1(IN := FALSE, PT := T#1000MS);
		END_IF

	250: (* === AUSWURF BEENDET === *)
		sStep := 'Auswurf_Beendet';
		
		Q_nErrorId := 0;
		
		IF I_bTaktFrg 
			AND NOT IQ_fbObjSchlauch.I_bTasteVereinzelung 
		THEN
			IQ_fbObjSchlauch.I_bSchrauberBelegt := FALSE;
			bAutoquitAktiv := FALSE;
			nStep := 10;	(* -> Zurück zur Bereitschaft *)
		END_IF

	// ================================================================================
	// FEHLERBEHANDLUNG
	// ================================================================================
	
	-40: (* === FEHLER: SCHRAUBE FEHLT === *)
		sStep := 'FEHLER_Schraube_fehlt';
		Q_nErrorId := -40;
		
		IF I_bQuittFehler
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-45: (* === FEHLER: LANGSAME GESCHWINDIGKEIT === *)
		sStep := 'FEHLER_Langsame_Geschwindigkeit';
		Q_nErrorId := -45;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-50: (* === FEHLER: SCHRAUBTIEFE FÜR SOLLDREHZAHL === *)
		sStep := 'FEHLER_Schraubtiefe_Solldrehzahl';
		Q_nErrorId := -50;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-60: (* === FEHLER: SOLLTIEFE NICHT ERREICHT === *)
		sStep := 'FEHLER_Solltiefe_nicht_erreicht';
		Q_nErrorId := -60;
		Q_bDrehmomentFehler := TRUE;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-61: (* === FEHLER: SOLLTIEFE ÜBERSCHRITTEN === *)
		sStep := 'FEHLER_Solltiefe_ueberschritten';
		Q_nErrorId := -61;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-65: (* === FEHLER: SOLLDREHMOMENT NICHT ERREICHT === *)
		sStep := 'FEHLER_Solldrehmoment_nicht_erreicht';
		Q_nErrorId := -65;
		
		IF I_bQuittFehler
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-80: (* === FEHLER: SCHRAUBERSTANGE === *)
		sStep := 'FEHLER_Schrauberstange_Bewegung';
		Q_nErrorId := -80;
		
		IF I_bQuittFehler 
			AND I_bGrdstlgSchrEinh 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 100;	(* -> Beenden *)
		END_IF

	-210: (* === FEHLER: AUSWURF === *)
		sStep := 'FEHLER_Auswurf_Vorgang';
		Q_nErrorId := -210;
		
		IF I_bQuittFehler 
		THEN
			bAutoquitAktiv := tonAutoquit.Q;
			bSchrAuswurfStart := TRUE;
			nStep := 240;	(* -> Auswurf zurückfahren *)
		END_IF

	END_CASE
	
ELSE
	// === RESET AKTIV ===
	nStep := 0;
END_IF

// ================================================================================
// ALLGEMEINE FUNKTIONEN UND ÜBERWACHUNG
// ================================================================================

// === GRUNDSTELLUNG ERZWINGEN ===
IF I_bGrundstellung 
THEN
	nStep := 0;
END_IF

// === AUTOMATISCHE QUITTIERUNG ===
tonAutoquit(
	IN := (Q_bError 
			AND I_tAutoQuit > T#0MS), 
	PT := I_tAutoQuit);

// === POSITIONSZUSTANDS-STRING ===
Q_sPosZustand := F_PosZustand(
	I_sString := I_sPosBeschreibung, 
	I_nStep := nStep, 
	I_sStep := sStep);

// === IST-SCHRAUBTIEFE AKTUALISIEREN ===
fSchraubTiefeIst := arrNcAchsen[I_nEncId].fPosIstwert;

// === DREHMOMENT-MITTELWERTBILDUNG ===
m_DrehmomentMittelwert();

// === SCHRAUBTAKT-ZEITMESSUNG ===
m_SchraubtaktMessung();

// === DIAGNOSE-HISTORIE ===
m_DiagnoseHistorie();

// === STILLSTANDS-ÜBERWACHUNG ===
m_StillstandsUeberwachung();

// === TIMER FÜR SCHRITTÜBERWACHUNG ===
tonDelay1(IN := nStep = nOldStep, PT := T#1D);
nOldStep := nStep;

// === STEP-HISTORIE ===
fbStepHistory(I_nStep := nStep);]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_LoggingUndDiagnose" Id="{ebff6659-fd97-4c7a-95f0-e3ccfa8b994f}">
      <Declaration><![CDATA[METHOD m_LoggingUndDiagnose : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
LOGGING UND DIAGNOSE
================================================================================
Zentrale Verwaltung aller Log-Funktionen und statistischen Auswertungen.
Speichert Fehler, Schraubzeiten und Prozessdaten für Qualitätssicherung.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === STÜCKZÄHLER ===
rtrigStueckzaehler(CLK := Q_bDone);
IF rtrigStueckzaehler.Q THEN
	nStueckzaehler := nStueckzaehler + 1;
END_IF

// === FEHLER-LOGGING ===
rtrigSchrauberfehler(CLK := nStep < 0 AND I_stParam.bLogAnwahl);

fbLogToFile(
	I_bStart 			:= rtrigSchrauberfehler.Q,
	I_sDateipfad 		:= I_sDateipfad,
	I_sDateiname 		:= I_sPosBeschreibung,
	I_sUeberschrift 	:= 'Timestamp;Anzahl;Schraubzeit;Drehmoment;Schraubtiefe;Barcode;Fehlermeldung;$R',
	
	// Fehlerzustände
	I_bFehler1 			:= objError_Schrauber.I_fbFehler_Schrauberstange.I_bAktiv,
	I_bFehler2 			:= objError_Schrauber.I_fbFehler_Sollmoment.I_bAktiv,
	I_bFehler3 			:= objError_Schrauber.I_fbFehler_Tiefe.I_bAktiv,
	I_bFehler4 			:= objError_Schrauber.I_fbFehler_TiefeUeberschritten.I_bAktiv,
	I_bFehler5 			:= objError_Schrauber.I_fbFehlerAuswurf.I_bAktiv,
	I_bFehler6 			:= objError_Schrauber.I_fbFehlerLangsameGeschwindigkeit.I_bAktiv,
	I_bFehler7 			:= objError_Schrauber.I_fbFehlerNachladen.I_bAktiv,
	I_bFehler8 			:= objError_Schrauber.I_fbFehlerTiefeSolldrehzahl.I_bAktiv,
	
	// Fehlerbeschreibungen
	I_sFehler1 			:= 'Fehler beim heben/senken der Schrauberstange',
	I_sFehler2 			:= 'Fehler - Drehmoment wird nicht erreicht',
	I_sFehler3 			:= 'Fehler - Tiefe wird nicht erreicht',
	I_sFehler4 			:= 'Fehler - Tiefe ueberschritten',
	I_sFehler5 			:= 'Fehler - Auswerfen',
	I_sFehler6 			:= 'Fehler - Langsame Geschwindigkeit wird nicht erreicht',
	I_sFehler7 			:= 'Fehler - Schraube fehlt',
	I_sFehler8 			:= 'Fehler - Schraubtiefe für Solldrehzahl wird nicht erreicht',
	
	// Prozessdaten
	I_sBarcode 			:= '',
	I_nAnzahlVerschraubungen := nStueckzaehler,
	I_tSchraubzeit 		:= arrLetzteSchraubzeit[0],
	I_fDrehmoment 		:= arrLetzteMomente[0],
	I_fSchraubtiefe 	:= arrLetzteTiefe[0]);

// === LOG BEENDEN BEI ERFOLG ===
IF Q_bDone THEN
	fbLogToFile(I_bStart := FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_SchraubtaktMessung" Id="{a6b5c030-e9a8-4de3-aa6b-0d92ee7ad9b9}">
      <Declaration><![CDATA[METHOD m_SchraubtaktMessung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
SCHRAUBTAKT-ZEITMESSUNG
================================================================================
Misst die Schraubzeit für Diagnose und Optimierung.
Die Zeitmessung erfolgt während der aktiven Schraubphase.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === ZEITMESSUNG WÄHREND SCHRAUBPHASE ===
tonSchraubtakt(
	IN := nStep = 60 OR nStep = 160 OR nStep = 65,
	PT := T#100S);

// === ZEIT ERFASSEN ===
IF nStep = 60 OR nStep = 160 OR nStep = 65 THEN
	timeSchraubtakt := tonSchraubtakt.ET;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_StillstandsUeberwachung" Id="{7cf777f8-0ad6-42b0-a72e-ec693d04e8f2}">
      <Declaration><![CDATA[METHOD m_StillstandsUeberwachung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
STILLSTANDS-ÜBERWACHUNG
================================================================================
Überwacht den Stillstand von Achsen mit Verzögerung zur Vermeidung
von Fehlmeldungen bei kurzen Bewegungspausen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === VERZÖGERTER STILLSTAND ===
tonVerzStillstand(
	IN := arrNcAchsen[I_nAchsId].stStatus.bInStillst,
	PT := T#10MS);]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Schrauber_PnP_2">
      <LineId Id="222" Count="28" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_Ausgangszuweisung">
      <LineId Id="13" Count="2" />
      <LineId Id="48" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="17" Count="2" />
      <LineId Id="50" Count="0" />
      <LineId Id="20" Count="4" />
      <LineId Id="51" Count="0" />
      <LineId Id="25" Count="3" />
      <LineId Id="52" Count="0" />
      <LineId Id="29" Count="18" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_DiagnoseHistorie">
      <LineId Id="13" Count="5" />
      <LineId Id="32" Count="0" />
      <LineId Id="19" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_DrehmomentMittelwert">
      <LineId Id="13" Count="1" />
      <LineId Id="36" Count="1" />
      <LineId Id="15" Count="20" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_Fehlerbehandlung">
      <LineId Id="13" Count="56" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_HandleReset">
      <LineId Id="15" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_Hauptablauf">
      <LineId Id="14" Count="1" />
      <LineId Id="752" Count="0" />
      <LineId Id="16" Count="21" />
      <LineId Id="753" Count="1" />
      <LineId Id="38" Count="19" />
      <LineId Id="755" Count="0" />
      <LineId Id="58" Count="2" />
      <LineId Id="756" Count="0" />
      <LineId Id="61" Count="6" />
      <LineId Id="757" Count="0" />
      <LineId Id="68" Count="6" />
      <LineId Id="758" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="759" Count="0" />
      <LineId Id="77" Count="10" />
      <LineId Id="760" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="761" Count="0" />
      <LineId Id="90" Count="4" />
      <LineId Id="762" Count="0" />
      <LineId Id="95" Count="17" />
      <LineId Id="763" Count="0" />
      <LineId Id="113" Count="18" />
      <LineId Id="764" Count="0" />
      <LineId Id="132" Count="8" />
      <LineId Id="765" Count="0" />
      <LineId Id="141" Count="17" />
      <LineId Id="766" Count="0" />
      <LineId Id="159" Count="11" />
      <LineId Id="767" Count="0" />
      <LineId Id="171" Count="13" />
      <LineId Id="768" Count="0" />
      <LineId Id="185" Count="2" />
      <LineId Id="769" Count="0" />
      <LineId Id="188" Count="12" />
      <LineId Id="770" Count="2" />
      <LineId Id="201" Count="20" />
      <LineId Id="773" Count="0" />
      <LineId Id="222" Count="4" />
      <LineId Id="774" Count="1" />
      <LineId Id="227" Count="3" />
      <LineId Id="776" Count="0" />
      <LineId Id="231" Count="11" />
      <LineId Id="777" Count="0" />
      <LineId Id="243" Count="2" />
      <LineId Id="778" Count="1" />
      <LineId Id="246" Count="2" />
      <LineId Id="780" Count="0" />
      <LineId Id="249" Count="24" />
      <LineId Id="781" Count="0" />
      <LineId Id="274" Count="5" />
      <LineId Id="782" Count="0" />
      <LineId Id="280" Count="14" />
      <LineId Id="783" Count="1" />
      <LineId Id="295" Count="6" />
      <LineId Id="785" Count="0" />
      <LineId Id="302" Count="6" />
      <LineId Id="786" Count="0" />
      <LineId Id="309" Count="26" />
      <LineId Id="787" Count="0" />
      <LineId Id="336" Count="9" />
      <LineId Id="788" Count="1" />
      <LineId Id="346" Count="15" />
      <LineId Id="791" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="790" Count="0" />
      <LineId Id="363" Count="4" />
      <LineId Id="793" Count="0" />
      <LineId Id="368" Count="0" />
      <LineId Id="792" Count="0" />
      <LineId Id="369" Count="5" />
      <LineId Id="794" Count="0" />
      <LineId Id="375" Count="0" />
      <LineId Id="795" Count="0" />
      <LineId Id="376" Count="12" />
      <LineId Id="796" Count="0" />
      <LineId Id="389" Count="16" />
      <LineId Id="797" Count="0" />
      <LineId Id="406" Count="15" />
      <LineId Id="798" Count="1" />
      <LineId Id="422" Count="15" />
      <LineId Id="800" Count="0" />
      <LineId Id="438" Count="3" />
      <LineId Id="801" Count="0" />
      <LineId Id="442" Count="16" />
      <LineId Id="802" Count="1" />
      <LineId Id="459" Count="12" />
      <LineId Id="804" Count="0" />
      <LineId Id="472" Count="4" />
      <LineId Id="805" Count="0" />
      <LineId Id="477" Count="14" />
      <LineId Id="806" Count="1" />
      <LineId Id="492" Count="18" />
      <LineId Id="808" Count="2" />
      <LineId Id="511" Count="11" />
      <LineId Id="811" Count="2" />
      <LineId Id="523" Count="15" />
      <LineId Id="814" Count="0" />
      <LineId Id="539" Count="2" />
      <LineId Id="815" Count="0" />
      <LineId Id="542" Count="9" />
      <LineId Id="816" Count="0" />
      <LineId Id="552" Count="15" />
      <LineId Id="817" Count="0" />
      <LineId Id="568" Count="3" />
      <LineId Id="818" Count="0" />
      <LineId Id="572" Count="9" />
      <LineId Id="819" Count="0" />
      <LineId Id="582" Count="16" />
      <LineId Id="820" Count="0" />
      <LineId Id="599" Count="3" />
      <LineId Id="821" Count="0" />
      <LineId Id="603" Count="11" />
      <LineId Id="822" Count="1" />
      <LineId Id="615" Count="13" />
      <LineId Id="824" Count="1" />
      <LineId Id="629" Count="9" />
      <LineId Id="826" Count="1" />
      <LineId Id="639" Count="9" />
      <LineId Id="828" Count="1" />
      <LineId Id="649" Count="10" />
      <LineId Id="830" Count="1" />
      <LineId Id="660" Count="9" />
      <LineId Id="832" Count="1" />
      <LineId Id="670" Count="9" />
      <LineId Id="834" Count="1" />
      <LineId Id="680" Count="9" />
      <LineId Id="836" Count="1" />
      <LineId Id="690" Count="9" />
      <LineId Id="838" Count="0" />
      <LineId Id="700" Count="17" />
      <LineId Id="839" Count="0" />
      <LineId Id="718" Count="5" />
      <LineId Id="840" Count="0" />
      <LineId Id="724" Count="27" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_LoggingUndDiagnose">
      <LineId Id="13" Count="44" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_SchraubtaktMessung">
      <LineId Id="13" Count="7" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Schrauber_PnP_2.m_StillstandsUeberwachung">
      <LineId Id="13" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>