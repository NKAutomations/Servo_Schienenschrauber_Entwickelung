<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="fb_SKSSchraubNob" Id="{7264520c-c401-4547-9877-f980c7765746}" SpecialFunc="None">
    <Declaration><![CDATA[(*======================================================================================================================================*)
(*//=============================================================================\\
||  _   _ _  __  _         _                        _   _                      ||
|| | \ | | |/ / / \  _   _| |_ ___  _ __ ___   __ _| |_(_) ___  _ __         ||
|| |  \| | ' / / _ \| | | | __/ _ \| '_ ` _ \ / _` | __| |/ _ \| '_ \        ||
|| | |\  | . \/ ___ \ |_| | || (_) | | | | | | (_| | |_| | (_) | | | |       ||
|| |_| \_|_|\_\_/  \_\__,_|\__\___/|_| |_| |_|\__,_|\__|_|\___/|_| |_|       ||
||                                                                             ||
\\=============================================================================//
SERVOSCHRAUBER - Schraubprozess Schubkastenschiene Nobilia Vorgabe  

Dieser Baustein beschreibt den reinen Schraubprozess, es wird lediglich die 
Motoransteuerung übernommen, alles andere (Pneumatik und Schraubenzuführung) 
kann weiterhin in dem standart Schrauber Baustein stattfinden. Dies sorgt
für eine verbesserte Integration in bereits bestehende Systeme.

Die Gesamte Motoransteuerung findet über die "IQ_SchrauberAchsStruc_InOut" -
Achsstruktur statt, welche zusammen mit dem Baustein aufgerufen und beschrieben
wird. 

Über die "I_stSchraubParam" Struktur werden die Gesamten benötigten Parameter 
an den Schrauber- Baustein übergeben. Diese Struktur kann unverändert
durchgereicht werden.

================================================================================
Vollautomatischer Servoschrauber für Schienen- und Einzelschrauben
mit NC-Achsenanbindung, Drehmoment, Drehwinkel- und Tiefenüberwachung 
================================================================================*)

(*Date          | Version    		| created under     | Author       		| Remark *)
(*====================================================================================================================================================*)
(*23/09/2025   	| 1.00      		| TC3		  		| N.Kersting       	| Neue Isolierte Version *)
(*30/09/2025   	| 1.01      		| TC3		  		| N.Kersting       	| Erste Versuche ohne Motor  *)
(*01/10/2025   	| 1.02      		| TC3		  		| N.Kersting       	| Neue Strukturen Integriert für Prozessdaten etc. *)
(*08/10/2025   	| 1.03      		| TC3		  		| N.Kersting       	| Erste Versuche laufen sehr gut in der Praxis *)
(*09/10/2025   	| 1.04      		| TC3		  		| N.Kersting       	| Merhrere kleine Bugfixe/ Merker wurden nicht Initialisiert... *)
(*09/10/2025   	| 1.05      		| TC3		  		| N.Kersting       	| Drehmomenterhöhung in Schraubfall 1 und 3 nun über Zeit entprellt *)
(*09/10/2025   	| 2.00      		| TC3		  		| N.Kersting       	| Komplette Auswertungsstrategie abgespeckt und anderes konzept, ohne Tiefe zu beachten *)
(*10/10/2025   	| 3.00      		| TC3		  		| N.Kersting       	| Nach Drehmoment Ok wird nun auch die Schraubtiefe in Abhängikeit des Drehwinkels geprüft *)
(*10/10/2025   	| 3.01      		| TC3		  		| N.Kersting       	| Lauffähiger Stand, Auswertung sehr genau, Schraubzeit ca. 500-650ms *)
(*10/10/2025   	| 3.02      		| TC3		  		| N.Kersting       	| Zeiten Diagnose implementiert (jeder step wird Zeitlich mitgeloggt)  *)
(*13/10/2025   	| 3.03      		| TC3		  		| N.Kersting       	| Drehmomentmittelwert nun aus nur 3 Werten um weniger Verzögerung zu bekommen  *)
(*14/10/2025   	| 3.04      		| TC3		  		| N.Kersting       	| Einige Parameter entfernt und neue Interne Parameter hinzugefügt inkl Nachziehen  *)
(*15/10/2025   	| 4.00      		| TC3		  		| N.Kersting       	| Auswertung Komplett überarbeitet, Parameter besser unterteilt wieder 5 werte bei Drehmoment Mittelwert  *)
(*20/10/2025   	| 4.01      		| TC3		  		| N.Kersting       	| Bugfixe Fehlermeldungen ergänzt und besser beschrieben  *)
(*20/10/2025   	| 4.02      		| TC3		  		| N.Kersting       	| Neu: Drehmoment erhöhen nach erreichen des Drehmoments um den Schraubfall sicher zu erkennen  *)
(*21/10/2025   	| 4.03      		| TC3		  		| N.Kersting       	| Neu: Schraubfall wird nun auch ausgegeben *)
(*21/10/2025   	| 5.00      		| TC3		  		| N.Kersting       	| Umstellung auf andere Klemme(EL7221 (8A)) hat ergeben, dass die Drehmomentberechnung
																			 	falsch war, es wurde bScheitelEffektivwert hinzugefügt, welcher gesetzt werden muss, wenn 
																				Index 0x8010:54 = 1, sonst FALSE. Außerdem gibt es nun einen Einrichtbetrieb für das Drehmoment *)
(*22/10/2025   	| 6.00      		| TC3		  		| N.Kersting       	| Ablauf komplett überarbeitet: -Alles unnötige entfernt, es gibt nun keine Absenkung der Drehzahl,
																				die Drehzahl wird nun durch erreichen des Sollmoments automatisch verringert, das spart Zeit und 
																				ist um Welten zuverlässiger. Ganzer Ablauf deutlich effizienter als vorher *)
(*22/10/2025   	| 6.01      		| TC3		  		| N.Kersting       	| Wichtige Performance Probleme beseitigt, Schrauberablauf nun wieder Schnell und effizient, 
																				zusätzlich um einiges Abgespeckt und Ablauf schlanker gemacht, und unnötige Schritte und Funktionen entfernt. *)
(*23/10/2025   	| 7.00      		| TC3		  		| N.Kersting       	| Neue AutoTest Funktion, wo das Maximal mögliche Drehmoment ertestet werden kann, und Verbesserte Fehlerauswertung *)	
(*24/10/2025   	| 7.01      		| TC3		  		| N.Kersting       	| Parameter umfassend erweitert und Gesamten Ablauf nochmals etwas verbessert. 
																				Es werden keine Werte mehr stumpf im Code geschrieben, es gibt für alles interne Parameter *)																				
(*====================================================================================================================================================*)
FUNCTION_BLOCK fb_SKSSchraubNob
VAR_INPUT
	I_bStart			:BOOL;
	I_bFreigabe			:BOOL;
	I_bReset			:BOOL;
	I_bQuittFehler		:BOOL;
	
	I_lrActPosTiefe		:LREAL;
	
	I_stSchraubParam	:ST_SchrauberAblauf_Parameter;	(* Speziefische Parameter für den Schruabprozess *)
	
END_VAR
VAR_OUTPUT
	Q_sState			:STRING;
	Q_bBusy				:BOOL;
	Q_bDone				:BOOL;
	Q_bError			:BOOL;
	Q_nErrorId			:INT;
	Q_bSchrHalt			:BOOL;				(* Motor stoppen *)
	Q_bAxisReset		:BOOL;				(* Achse zurücksetzen *)
	Q_nTorque			:INT := 300;		(* Drehmomentgrenzwert [0.1%] *)
	
	Q_stProzessDaten	:ST_SchrauberAblauf_ProzessDaten;
END_VAR
VAR_IN_OUT
	(* Schraubantrieb Achsstruktur InOut *)
	IQ_SchrauberAchsStruc_InOut		:ST_SchrauberAblauf_AchsStruc;
END_VAR
VAR
	nStep				: INT;
	sStep				: STRING;
	bBusy				: BOOL;
	bDone				: BOOL;
	
	(*========================================================================================================================*)
	(* === PROZESSWERTE === *)
	(*========================================================================================================================*)
	fSchraubTiefeIst				: LREAL;	(* Aktuelle Schraubtiefe [mm] *)
	fDrehmomentIstMittel			: LREAL;	(* Gemitteltes Drehmoment [0.1%] *)
	nTiefeBeimAufsetzen				: LREAL;	(* Tiefe beim ersten Werkstückkontakt *)
	bTiefeBeimAufsetzenOK			: BOOL;		(* Aufsetzen korrekt erkannt *)
	
	(* Memory *)
	bTiefeOkMem						: BOOL;
	bDrehmomOkMem					: BOOL;
	bDrehwinkelOkMem				: BOOL;
	bTiefeStehtOkMem				: BOOL;
	bSchraubStangeStehtOkMem		: BOOL;
	bDrehwinkelTiefeOkMem			: BOOL;
	nDrehwinkelMem					: LREAL;
	nTiefErrechnetMem				: LREAL;
	nTiefeAbweichMem				: LREAL;
	nAuswertungTiefeMem				: LREAL;	(* Gemerkte Tiefe für Auswertung in Step 60 *)
	nAuswertungPosMem				: LREAL;	(* Gemerkte Position für Auswertung in Step 60 *)
	nDrehmomEinrichtenMem			: LREAL;
	
	nSollDrehmomentErrechnet		: LREAL;	(* Der errechnete Drehmomentwert, Rechnet Drehmoment (Nm) um in Prozessdaten kompatibelen wert für den Antrieb! *)
	bAchsreset						: BOOL;		(* Achsen-Reset intern *)
	lrDrehzahlSollProzent			: LREAL;
	
	(*========================================================================================================================*)
	(* === FEHLERBEHANDLUNG === *)
	(*========================================================================================================================*)
	nFehlerSchrittMerker			: INT;		(* Merker für Fehlerschritt *)
		
	(*========================================================================================================================*)
	(* === Auswertung === *)
	(*========================================================================================================================*)
	fbtimeDiff_Schraub				: fb_timeDiff;
	fbtimeDiff_Step45				: fb_timeDiff;
	fbtimeDiff_Step50				: fb_timeDiff;
	fbtimeDiff_Step60				: fb_timeDiff;
	fbtimeDiff_Step61				: fb_timeDiff;
	fbtimeDiff_Step62				: fb_timeDiff;
	fbtimeDiff_Step63				: fb_timeDiff;
	fbtimeDiff_Step70				: fb_timeDiff;
	fbtimeDiff_Step75				: fb_timeDiff;
	
	rTrigZeitenSchreiben			: R_trig;
	rTrigPosMem						: R_trig;
	
	stArraySteps					: ARRAY[1..10] OF STRING;
	tGesamtZeit						: TIME;
	sGesamtZeit						: STRING;
	i								: INT;
	
	(*========================================================================================================================*)
	(* === Zeiten === *)
	(*========================================================================================================================*)
	tonTimeOver						: ton;
	tonStillstand					: ton;
	
	(*========================================================================================================================*)
	(* === DREHMOMENT-MITTELWERTBILDUNG === *)
	(*========================================================================================================================*)
	arrDrehmomentIst				: ARRAY [0..5] OF LREAL;	(* Ringpuffer für Drehmoment, nur noch 5 Werte als Glättung um schneller zu werden *)
	idx								: INT;						(* Index für Array-Verarbeitung *)
	
	(*========================================================================================================================*)
	(* === Prozesswerte für Analyse === *)
	(*========================================================================================================================*)
	nPD_Tiefe						: LREAL;			(* Prozessdaten - erreichte Tiefe *)
	nPD_Drehmoment					: LREAL;			(* Prozessdaten - erreichtes Drehmoment *)
	nPD_Drehwinkel					: LREAL;			(* Prozessdaten - erreichter Drehwinkel *)
	nPD_DrehwinkelAnzug				: LREAL;			(* Prozessdaten - erreichter Drehwinkel bei Anzug*)
	tPD_Schraubtakt					: TIME;				(* Prozessdaten - Zeit nur für den Schraubvorgang ohne Zylinder bewegungen etc. *)
	bPD_SchraubVorgOk				: BOOL;				(* Prozessdaten - Schraubvorgang OK *)
	iPD_Schraubfall					: INT;				(* Prozessdaten - Schraubfall (0=Undefiniert, 1= Weich, 2= Hart-Früh, 3= Hart-Spät, 4= ZuTief, 5=Tiefe nicht erreicht ) *)
	
	(*========================================================================================================================*)
	(* === Interne Parameter Schrauberablauf === *)	
	(*========================================================================================================================*)
	(* Wenn True wird in Step 61 Sobald das Drehmoment und Tiefe Ok sind, eine Tiefenprüfung mit Drehwinkelabhängigkeit durchgeführt *)
	bSchraubfallAuswertung			: BOOL := TRUE;		(* kann auch deaktiviert werden, muss getestet werden *)
	
	(*========================================================================================================================*)
	(* Wenn True wird in Step 63 eine reine Tiefenprüfung Durchgeführt, wo ausschließlich die Tiefe in der Toleranz sein muss *)
	bTiefenAuswertung				: BOOL := TRUE;		(* Sollte immer genutzt werden, da sehr zuverlässig *)
	
	(*========================================================================================================================*)
	(* Wenn True wird in Step 62 nachdem eine Tiefenänderung Festgestellt wird, erneut bei Schritt 60 begonnen um Nachzuziehen *)			
	bNachziehenBeiSchraubfallWeich	: BOOL := FALSE;	(* nicht sinnvoll, da es bei einem Weichenschraubfall meit keine schiene gibt und ein Fehler kommen muss *)
		
	nFaktorErkStillstandEindrehen	: LREAL := 0.5;		(* Prozentuale Drehzahl um Stillstand zu erkennen 0.5 = 50% der Solldrehzahl beim eindrehen *)
	nFaktorErkStillstandNachziehen	: LREAL := 0.1;		(* Prozentuale Drehzahl um Stillstand zu erkennen 0.5 = 50% der Solldrehzahl beim eindrehen *)
	
	(*========================================================================================================================*)
	(* Drehmoment Einricht funktion, springt nach dem erreichen der Tiefe in einen Schritt, wo nur das Drehmoment aus der Einrichtfunktion genutzt wird, 
		zur Diagnose  *)
	fbDrehmomRampe					: fb_TimeStepUp;	
	bDrehmomentEinrichten			: BOOL := FALSE;
	nDrehmomentEinrichten			: LREAL := 1;		
	nDrehmomentEinrichtenStart		: LREAL := 1;		(* Start Drehmoment *)
	nDrehmomentEinrichtenMax		: LREAL := 3.2;		(* Start Drehmoment *)
	nDrehmomentEinrichtenSteps		: LREAL := 0.1;		(* Drehmoment Schritte *)
	tVerzStillstand					: TIME 	:= T#600MS;	(* Zeit für Stillstand erreicht *)
	nDrehzahlEinrichten				: LREAL := 1800;	(* Drehzahl *)
	nMaxAutoTestsDrehmom			: LREAL;			(* Maximal Erreichtes Drehmoment vor Durchdrehen *)
	
	(*========================================================================================================================*)
	(* Wichtiger Parameter zur Drehmomentberechnung! *)
	bScheitelEffektivwert			: BOOL := TRUE;		(* TRUE, wenn Index 0x8010:54 = 1, sonst FALSE *)
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fSchraubTiefeIst :=	I_lrActPosTiefe;

(* === Hauptablauf === *)
ac_Hauptablauf();
ac_Fehler();
ac_AutoTest();

(* === DREHMOMENT-MITTELWERTBILDUNG === *)
m_DrehmomentMittelwert();

(* === SCHRAUBTAKT-ZEITMESSUNG === *)
m_SchraubtaktMessung();

(* === Ausgänge zuweisen === *)
m_Ausgangszuweisung();
]]></ST>
    </Implementation>
    <Folder Name="Ablauf" Id="{fafa4d6d-6f22-46f3-bf08-cf1d510a3348}" />
    <Folder Name="Auswertung" Id="{6546e813-580a-4c40-8d8a-37f1e1c6b5fe}" />
    <Folder Name="Methoden" Id="{5cc9686a-2a29-40e1-8435-8fae6eccb819}">
      <Folder Name="Ausgang" Id="{6aba5681-4e5c-480a-99f0-c6a63017ffef}" />
      <Folder Name="Diagnose" Id="{30f33323-bedf-4681-9716-d32c8fe17ccb}" />
      <Folder Name="Drehmoment" Id="{4f4c9446-1ae7-4f1c-abfe-f801565df70b}" />
      <Folder Name="Pruefung" Id="{85b2db60-3bc3-4c45-ab1d-146f31338f7e}" />
      <Folder Name="Rechner" Id="{a1e596fa-1c68-4ed0-91bf-d850752cd9d3}" />
    </Folder>
    <Action Name="ac_60_Eindrehen" Id="{beebda9e-eedb-48f2-8a4a-07155c41ec40}" FolderPath="Auswertung\">
      <Implementation>
        <ST><![CDATA[(* === Eindrehen- schrauben bis Kopfauflage erreicht === *)
sStep := 'Eindrehvorgang gestartet- Warte auf Drehmoment, und Stillstand';

(* Watchdog für Auswertung Schraubfall *)
tonTimeOver.IN := TRUE;
tonTimeOver.PT := I_stSchraubParam.tSchraubfallAuswertung;
	
IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := I_bFreigabe;

(* Aufruf Drehmoment Prüfen *)
m_DrehmomentPruefung(
	nDrehmomentSoll:= 		I_stSchraubParam.nDrehmomentSoll, 
	bDrehmomentOk=> 		bDrehmomOkMem);

(* Aufruf Drehwinkel Prüfen *)
m_DrehwinkelPruefung(
		nPosAct:= 			IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActPos, 
		nPosMem:= 			nAuswertungPosMem, 
		nMaxDrehwinkel :=	stParamSKSServoschrauber_Neu.nMaxDrehwinkelDrehmomAuswert, (* Maximal Drehwinkel vor Drehmoment ok *)
		bWinkelOk=> 		bDrehwinkelOkMem,
		nWinkelAct=>		nDrehwinkelMem);
		
(* Drehwinkel Schreiben *)
nPD_Drehwinkel :=	nDrehwinkelMem;
	
(* NachziehDrehzahl setzen *)
m_DrehzahlVorgabe(
	lrMaxDrehzahl:=  		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw, 
	lrDrehzahlSollUpm:= 	I_stSchraubParam.nSollDrehzahlNachziehen,	(* Solldrehzahl zum Nachziehen *) 
	lrDrehzahlVorgabe=> 	lrDrehzahlSollProzent);

(* Aufruf Schrauberstange auf Stillstand Prüfen *)	
m_StillstandPruef(
	nIstDrehzahl:= 		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActVelo, 
	nMinDrehzahl:= 		ABS((IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw*lrDrehzahlSollProzent/100) * nFaktorErkStillstandEindrehen), (* nFaktorErkStillstandEindrehen% der Sollgeschwindikeit *)
	bSteht=> 			bSchraubStangeStehtOkMem);
			
IF NOT  tonTimeOver.Q 
THEN
	IF bDrehmomOkMem 
	THEN
		(* Drehzahl herabsetzen sobald das Drehmoment OK ist *)
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := I_bFreigabe;
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_nPTPVelo := lrDrehzahlSollProzent  ;	
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_PTPBuffMode := MC_BlendingNext;
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := I_bFreigabe;
			
		IF bSchraubStangeStehtOkMem
		THEN
			(* Werte Merken zur Auswertung *)
			nAuswertungPosMem := IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActPos; (* Position Merken, wo Drehmoment erreicht wurde *)	
			nAuswertungTiefeMem :=	fSchraubTiefeIst; (* Tiefe Merken, wo Drehmoment erreicht wurde *)
			
			tonTimeOver.IN := FALSE;
			
			IF fSchraubTiefeIst <= I_stSchraubParam.nTiefeDrehmom
			THEN
				nStep := 61;
			ELSE
				tonTimeOver.IN := FALSE;
				nFehlerSchrittMerker := -602;	(* -> Tiefe für Drehmoment Ok passt nicht zur Situation - Das Drehmoment ist zu Früh gekommen*) (* Fehlercode merken *)
				nStep := 70;					(* -> Direkter Abbruch *)
			END_IF
		END_IF
		
	ELSIF
		NOT bDrehwinkelOkMem
		AND ABS(nDrehwinkelMem) >(I_stSchraubParam.nMaxDrehwinkelNachDrehmOk) 
	THEN
		tonTimeOver.IN := FALSE;
		nFehlerSchrittMerker := -601;	(* -> Drehwinkel überschritten bei Auswertung Drehmoment *) (* Fehlercode merken *)
		nStep := 70;					(* -> Direkter Abbruch *)
	END_IF
ELSE			
	IF bSchraubStangeStehtOkMem
		AND NOT bDrehmomOkMem
	THEN
		tonTimeOver.IN := 	FALSE;
		nFehlerSchrittMerker := -603; 	(* Fehlercode merken Timeout Drehmoment konnte nicht erreicht werden *)	
		nStep := 70;					(* -> Direkter Abbruch *)
	ELSIF
		NOT bSchraubStangeStehtOkMem
		AND bDrehmomOkMem
	THEN
		tonTimeOver.IN := 	FALSE;
		nFehlerSchrittMerker := -604; 	(* Fehlercode merken Timeout Drehmoment Ok, aber kein Stillstand *)
		nStep := 70;					(* -> Direkter Abbruch *)
	ELSE
		tonTimeOver.IN := FALSE;
		nFehlerSchrittMerker := -60;	(* Fehlercode merken Timeout kein Drehmoment und keinen Stillstand *)	
		nStep := 70;					(* -> Direkter Abbruch *)
	END_IF
	
	
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac_61_Nachziehen" Id="{5c67398b-963c-4b49-9885-21994fb5412b}" FolderPath="Auswertung\">
      <Implementation>
        <ST><![CDATA[(*================================================================================================================*)
(*Finale Auswertung (Drehmoment, Drehwinkel & Stillstand):**
    *   Um den Schraubfall sicher zu klassifizieren, wird die Drehmomentvorgabe erhöht. 
		Dies erzwingt ein minimales Weiterdrehen und liefert klarere Sensorsignale.
    *   Es wird geprüft, ob der zusätzliche Drehwinkel nach Erreichen des Zieldrehmoments in einem engen Fenster bleibt.
    *   Gleichzeitig wird überwacht, ob die Schrauberachse zum Stillstand kommt.
    *   Sind beide Kriterien (Winkel im Fenster & Stillstand) erfüllt, war der Anzug erfolgreich.*)
(*================================================================================================================*)
sStep := 'Nachziehvorgang Auswertung Drehwinkel und Drehmoment';

(* Watchdog für Schraubvorgang *)
tonTimeOver.IN := 	TRUE;
tonTimeOver.PT :=	I_stSchraubParam.tZeitdSchraubfallTimeout;


(* Drehmoment Vorgabe errechnen für erhöhung des Drehmoments um ein Weiterdrehen zu erzwingen!-> Schraubfall kann besser ausgewertet werden*)
m_DrehmomentVorgabe(
	nSkalierung :=			I_stSchraubParam.nDrehmomentSkalierVorgabe,
	nTorque:= 				I_stSchraubParam.nDrehmomentMax, 
	nRatedCurrentMotor:= 	I_stSchraubParam.nNennleistungMotor, 
	nTorqueConstant:= 		I_stSchraubParam.nDrehmomentKonstante, 
	bIndexIsOne :=			bScheitelEffektivwert,
	nTorqueLimitation=> 	nSollDrehmomentErrechnet);

(* Drehmoment wieder Setzen damit der Motor weiter drehen kann *)			
Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet );	

(* Aufruf Drehwinkel Prüfen *)
m_DrehwinkelPruefung(
	nPosAct:= 			IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActPos, 
	nPosMem:= 			nAuswertungPosMem, 
	nMaxDrehwinkel :=	I_stSchraubParam.nMaxDrehwinkelNachDrehmOk, (* Maximal Drehwinkel nach Drehmoment ok *)
	bWinkelOk=> 		bDrehwinkelOkMem,
	nWinkelAct=>		nDrehwinkelMem);

(* Anzugsdrehwinkel Schreiben *)
nPD_DrehwinkelAnzug := nDrehwinkelMem;
			
(* Aufruf Drehmoment Prüfen *)
m_DrehmomentPruefung(
	nDrehmomentSoll:= 		I_stSchraubParam.nDrehmomentMax, 
	bDrehmomentOk=> 		bDrehmomOkMem);

(* Aufruf Schrauberstange auf Stillstand Prüfen *)	
m_StillstandPruef(
	nIstDrehzahl:= 		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActVelo, 
	nMinDrehzahl:= 		ABS((IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw*lrDrehzahlSollProzent/100) * nFaktorErkStillstandNachziehen), (* nFaktorErkStillstandNachziehen% der Sollgeschwindikeit *)
	bSteht=> 			bSchraubStangeStehtOkMem);

(* Stillstandmerker verzögern *)	
tonStillstand.IN :=		bSchraubStangeStehtOkMem;
tonStillstand.PT := 	T#4MS;	(* 1 Zykluszeit *)
	
IF NOT tonTimeOver.Q
THEN
	(* Schrauberstange dreht sich nicht mehr und Drehmoment erreicht *) 
	IF  tonStillstand.Q 
		AND bDrehmomOkMem
	THEN 	
		tonTimeOver.IN := 	FALSE;
		Q_nTorque := 0;	
		
		(* Schraubfall auswertung Aktiviert *)
		IF bSchraubfallAuswertung
		THEN
			nStep := 62;	(* -> Tiefen Änderung Prüfen *)
		ELSE			
			(* Tiefen auswertung Aktiviert *)
			IF bTiefenAuswertung
			THEN
				nStep := 63;	(* -> Tiefe Prüfen *)
			ELSE
				nStep := 70;	(* -> Motor stoppen *)
			END_IF
		END_IF
	ELSIF
		(* Drehwinkel Überschritten *)
		NOT bDrehwinkelOkMem
		AND ABS(nDrehwinkelMem) >(I_stSchraubParam.nMaxDrehwinkelNachDrehmOk)
	THEN
		(* Wenn Drehwinkel Überschritten-> Direkt Anhalten *)
		tonTimeOver.IN := 	FALSE;
		
		(* Drehmoment Speichern *)
		nPD_Drehmoment :=	fDrehmomentIstMittel;	
		
		IF bDrehmomOkMem 
		THEN
			IF bSchraubfallAuswertung
			THEN
				Q_nTorque := 0;
				iPD_Schraubfall	:= 3;			(* Prozessdaten - Schraubfall Hart-Spät*)
				nStep := 62;					(* Weil das Drehmoment noch Ok ist, kann nun der Schraubfall ausgewertet werden, damit wir eine bessere Aussage erhalten, was los war *)
			ELSE
				Q_nTorque := 0;
				nFehlerSchrittMerker := -612;	(* Fehlercode merken Drehwinkel Überschritten, Drehmoment Ok *)
				nStep := 70;					(* -> Direkter Abbruch *)
			END_IF
		ELSE
			IF bSchraubfallAuswertung
			THEN
				Q_nTorque := 0;
				iPD_Schraubfall	:= 1;			(* Prozessdaten - Schraubfall Weich*)
				nFehlerSchrittMerker := -611;	(* Fehlercode merken Drehwinkel Überschritten, Drehmoment nicht erreicht *)
				nStep := 62;					(* Trotzdem herausfinden, was für ein Schraubfall vorliegt *)
			ELSE
				Q_nTorque := 0;
				nFehlerSchrittMerker := -611;	(* Fehlercode merken Drehwinkel Überschritten, Drehmoment nicht erreicht *)	
				nStep := 70;					(* -> Direkter Abbruch *)	
			END_IF
		END_IF
		
	END_IF
ELSE
	(* Drehmoment Speichern *)
	nPD_Drehmoment :=	fDrehmomentIstMittel;	
	
	IF bSchraubStangeStehtOkMem
		AND NOT bDrehmomOkMem
	THEN
		tonTimeOver.IN := 	FALSE;
		nFehlerSchrittMerker := -613; 	(* Fehlercode merken Timeout Nachziehdrehmoment konnte nicht erreicht werden *)	
		nStep := 70;					(* -> Direkter Abbruch *)	
	ELSIF
		NOT bSchraubStangeStehtOkMem
		AND bDrehmomOkMem
	THEN
		tonTimeOver.IN := 	FALSE;
		nFehlerSchrittMerker := -614; 	(* Fehlercode merken Timeout Drehmoment Ok, aber kein Stillstand *)
		nStep := 70;					(* -> Direkter Abbruch *)	
	ELSE
		tonTimeOver.IN := 	FALSE;
		nFehlerSchrittMerker := -61; 	(* Fehlercode merken Timeout kein Drehmoment und keinen Stillstand *)	
		nStep := 70;					(* -> Direkter Abbruch *)	
	END_IF
	
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac_62_Schraubfall" Id="{270db67a-4949-4c92-912d-219e1e9ec108}" FolderPath="Auswertung\">
      <Implementation>
        <ST><![CDATA[(*================================================================================================================*)
(* 	**Schraubfallprüfung (hart/weich) (Optional):**
    *   Unmittelbar nach dem Stillstand wird die Tiefenänderung analysiert.
    *   Bleibt die Tiefe konstant, liegt ein **harter Schraubfall** vor (erwartet bei Metall auf Holz).
    *   Ändert sich die Tiefe weiter, deutet dies auf einen **weichen Schraubfall** hin (z. B. Setzverhalten, fehlende Schiene) 
		und löst einen Fehler oder optional einen Nachziehversuch aus.*)
(*================================================================================================================*)
sStep := 'Schraubfallauswertung ';

(* Watchdog für Tiefenänderung *)
tonTimeOver.IN := TRUE;
tonTimeOver.PT :=  T#100MS;

m_TiefenAenderung(
	nTiefeStreckeIst:= 		ABS(fSchraubTiefeIst) -ABS(nAuswertungTiefeMem), 
	nDrehwinkelIst:= 		nDrehwinkelMem, 
	nSteigungSchraube:= 	I_stSchraubParam.nHoeheSchraubenDrehung, 
	nAbweichung:= 			100, (* in Prozent Abweichung *)
	nMinStrecke:=			0.09, (* Mindest Tiefen-Strecke, welche beim Nachziehen zurückgelegt werden muss, damit die Prüfung überhaupt aktiviert wird, da sonst zu ungenau*)
	nTiefeErrechnet=> 		nTiefErrechnetMem, 
	nProzentAbweichung=>	nTiefeAbweichMem,
	bTiefeSteht=> 			bTiefeStehtOkMem);
 
IF bTiefeStehtOkMem
THEN
	(* Harten Schraubfall erkannt *)
	tonTimeOver.IN := 	FALSE;
	Q_nTorque := 0;
	
	IF iPD_Schraubfall = 0
	THEN
		iPD_Schraubfall	:= 2; (* Prozessdaten - Schraubfall Hart, Früh*)
	ELSE
		iPD_Schraubfall	:= 3; (* Prozessdaten - Schraubfall Hart, Spät*)
	END_IF
	
	IF bTiefenAuswertung
	THEN
		nStep := 63;	(* -> Tiefe Prüfen *)
	ELSE
		nStep := 70;	(* -> Motor stoppen *)
	END_IF
	
ELSIF
	tonTimeOver.Q
THEN
	(* Weichen Schraubfall erkannt *)	
	tonTimeOver.IN := FALSE;
	iPD_Schraubfall	:= 1; 			(* Prozessdaten - Schraubfall Weich *)
	nFehlerSchrittMerker := -62;	(* -> Tiefe hat sich geändert Logik muss noch folgen, aber erst mal Fehler *) (* Fehlercode merken *)
	nStep := 70;					(* -> Direkter Abbruch *)	
	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac_63_Tiefe" Id="{8114a9b7-5400-41ff-b91c-67cce70a298f}" FolderPath="Auswertung\">
      <Implementation>
        <ST><![CDATA[(*================================================================================================================*)
(* **Finale Tiefenprüfung (optional):**
    *   Abschließend wird kontrolliert, ob die erreichte Endtiefe innerhalb der vorgegebenen Toleranz liegt.*)
(*================================================================================================================*)
sStep := 'Schraubtiefenauswertung';

Q_nTorque := 0;

(* Watchdog für Tiefenänderung *)
tonTimeOver.IN := TRUE;
tonTimeOver.PT :=  T#50MS;

(* Tiefenprüfung *)
m_TiefenPruefung(
	nSolltiefe:= 		I_stSchraubParam.nSchraubtiefeSoll, 
	nToleranz:= 		I_stSchraubParam.nSchraubtiefeToleranz,	 
	nActTiefe:= 		fSchraubTiefeIst, 
	bTiefeOk=> 			bTiefeOkMem);
 
IF bTiefeOkMem
THEN
	tonTimeOver.IN := 	FALSE;
	nStep := 70;	(* -> Motor stoppen *)
ELSIF
	tonTimeOver.Q
THEN
	tonTimeOver.IN := FALSE;
	
	IF fSchraubTiefeIst < I_stSchraubParam.nSchraubtiefeSoll-I_stSchraubParam.nSchraubtiefeToleranz
	THEN
		nFehlerSchrittMerker := -631;	(* -> Tiefe Unterschritten, Schiene fehlt vielleicht ? *)
		nStep := 70;					(* -> Direkter Abbruch *)
	ELSIF
		 fSchraubTiefeIst > I_stSchraubParam.nSchraubtiefeSoll+I_stSchraubParam.nSchraubtiefeToleranz
	THEN
		nFehlerSchrittMerker := -632;	(* -> Tiefe nicht erreicht, Bohrung nicht tief genug? *)
		nStep := 70;					(* -> Direkter Abbruch *)
	ELSE
		nFehlerSchrittMerker := -63;	(* -> Undefinierter Fehler *)
		nStep := 70;					(* -> Direkter Abbruch *)
	END_IF
	
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac_AutoTest" Id="{d94391a9-984b-4bc9-82be-eb2ea865945c}" FolderPath="Ablauf\">
      <Implementation>
        <ST><![CDATA[(* ================================================================================ *)
(* EINRICHTEN *)
(* ================================================================================ *)
CASE nStep OF
(* ================================================================================ *)
(* EINRICHTEN: Drehmoment *)
(* ================================================================================ *)
900: sStep := 'AutoTest Drehmoment';
			
	fbDrehmomRampe(
		I_bExecute:=	FALSE, 
		Q_nActStep=> 	nDrehmomentEinrichten);
		
	(* Drehmoment Vorgabe errechnen *)
	m_DrehmomentVorgabe(
		nSkalierung :=			I_stSchraubParam.nDrehmomentSkalierVorgabe,
		nTorque:= 				nDrehmomentEinrichten, 
		nRatedCurrentMotor:= 	I_stSchraubParam.nNennleistungMotor, 
		nTorqueConstant:= 		I_stSchraubParam.nDrehmomentKonstante, 
		bIndexIsOne :=			bScheitelEffektivwert,
		nTorqueLimitation=> 	nSollDrehmomentErrechnet);
	
	Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet); 

	(* Aufruf Schrauberstange auf Stillstand Prüfen *)	
	m_StillstandPruef(
		nIstDrehzahl:= 		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActVelo, 
		nMinDrehzahl:= 		ABS(IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw * 0.05), (* 5% der Bezugsgeschwindigkeit *)
		bSteht=> 			bSchraubStangeStehtOkMem);
	
	(* Aufruf Drehmoment Prüfen *)
	m_DrehmomentPruefung(
		nDrehmomentSoll:= 		nDrehmomentEinrichten *0.99, (* 99% des Sollmoments *)
		bDrehmomentOk=> 		bDrehmomOkMem);

	(* Watchdog für Stillstand *)
	tonTimeOver.IN := 	TRUE;
	tonTimeOver.PT :=  tVerzStillstand;
	
	IF NOT bDrehmomentEinrichten 
	THEN
		nStep := 70;
	ELSIF
		tonTimeOver.Q
	THEN
		IF bSchraubStangeStehtOkMem
			AND bDrehmomOkMem
		THEN
			tonTimeOver.IN := FALSE;
			nStep := 901;
		ELSE
			nMaxAutoTestsDrehmom := nDrehmomentEinrichten -nDrehmomentEinrichtenSteps;
			nStep := 902; (* ENDE *)
		END_IF
	END_IF
	
(* ================================================================================ *)
(* EINRICHTEN: Drehmoment warten auf neuen Wert*)
(* ================================================================================ *)
901: sStep := 'Einrichtbetrieb Stillstand erreicht- warte auf neue Vorgabe';
	
	Q_nTorque := 0; 
	
	(* Watchdog für Stillstand *)
	tonTimeOver.IN :=  TRUE;
	tonTimeOver.PT :=  T#2S;	(* Um die Klemmen Auslastung zu verringern  *)
		
	IF NOT bDrehmomentEinrichten 
	THEN
		nStep := 70;
	ELSE
		IF tonTimeOver.Q
		THEN
			nAuswertungPosMem := IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActPos;
			tonTimeOver.IN := 	FALSE;
			nStep := 903;
		END_IF
	END_IF
(* ================================================================================ *)
(* EINRICHTEN: Drehmoment warten auf neuen Wert*)
(* ================================================================================ *)
902: sStep := 'Einrichtbetrieb Stillstand erreicht- warte auf neue Vorgabe';
	
	tonTimeOver.IN := FALSE;
	Q_nTorque := 0; 
	
	IF NOT bDrehmomentEinrichten 
	THEN
		nDrehmomentEinrichten := nDrehmomentEinrichtenStart;
		nStep := 70;
	END_IF
	
(* ================================================================================ *)
(* EINRICHTEN: Drehmoment *)
(* ================================================================================ *)
903: sStep := 'AutoTest Drehmoment Rampe';
		
	fbDrehmomRampe(
		I_bExecute:=	TRUE, 
		I_nSteps:= 		nDrehmomentEinrichtenSteps, 
		I_nStart:= 		nDrehmomentEinrichtenStart, 
		I_nMax:= 		nDrehmomentEinrichtenMax, 
		I_tVerz:= 		T#50MS, 
		Q_nActStep=> 	nDrehmomentEinrichten);
	
	(* Drehmoment Vorgabe errechnen *)
	m_DrehmomentVorgabe(
		nSkalierung :=			I_stSchraubParam.nDrehmomentSkalierVorgabe,
		nTorque:= 				nDrehmomentEinrichten, 
		nRatedCurrentMotor:= 	I_stSchraubParam.nNennleistungMotor, 
		nTorqueConstant:= 		I_stSchraubParam.nDrehmomentKonstante, 
		bIndexIsOne :=			bScheitelEffektivwert,
		nTorqueLimitation=> 	nSollDrehmomentErrechnet);
	
	Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet); 

	(* Aufruf Schrauberstange auf Stillstand Prüfen *)	
	m_StillstandPruef(
		nIstDrehzahl:= 		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActVelo, 
		nMinDrehzahl:= 		ABS(IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw * 0.25), (* 25% der Bezugsgeschwindigkeit *)
		bSteht=> 			bSchraubStangeStehtOkMem);
	
	(* Aufruf Drehwinkel Prüfen *)
	m_DrehwinkelPruefung(
		nPosAct:= 			IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActPos, 
		nPosMem:= 			nAuswertungPosMem, 
		nMaxDrehwinkel :=	360, (* Maximal Drehwinkel nach Drehmoment ok *)
		bWinkelOk=> 		bDrehwinkelOkMem,
		nWinkelAct=>		nDrehwinkelMem);
	
	(* Aufruf Drehmoment Prüfen *)
	m_DrehmomentPruefung(
		nDrehmomentSoll:= 		nDrehmomentEinrichten *0.99, (* 99% des Sollmoments *)
		bDrehmomentOk=> 		bDrehmomOkMem);

	(* Watchdog für Stillstand *)
	tonTimeOver.IN := 	NOT bSchraubStangeStehtOkMem;
	tonTimeOver.PT :=  T#20MS;
	
	IF fDrehmomentIstMittel > nMaxAutoTestsDrehmom
	THEN
		nMaxAutoTestsDrehmom := fDrehmomentIstMittel;
	END_IF
	
	IF NOT bDrehmomentEinrichten 
	THEN
		nStep := 70;
	ELSIF
		tonTimeOver.Q				(* Geschwindigkeit angestiegen *)
		OR (nDrehwinkelMem >720) 	(* Überdreht *)
	THEN
		tonTimeOver.IN := FALSE;
		nStep := 902;
	END_IF
	
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac_Fehler" Id="{72e88650-2ab6-406a-9f47-6c0394bfd3df}" FolderPath="Ablauf\">
      <Implementation>
        <ST><![CDATA[(* ================================================================================ *)
(* FEHLERBEHANDLUNG 

	45 = 	FEHLER: Langsame Geschwindigkeit wird nicht erreicht

	50 = 	FEHLER: Timeout Schraubtiefe für Solldrehzahl wird nicht erreicht
	
	601 =	FEHLER EINDREHEN: Drehwinkel überschritten
	602 =	FEHLER EINDREHEN: Drehmoment Ok aber nicht Tief genug
	603 =	FEHLER EINDREHEN: Timeout Drehmoment konnte nicht erreicht werden
	604 =	FEHLER EINDREHEN: Timeout Drehmoment Ok, aber kein Stillstand
	60 =	FEHLER EINDREHEN: Timeout kein Drehmoment und keinen Stillstand
	
	611 =	FEHLER NACHZIEHEN: Drehwinkel Überschritten, Drehmoment nicht erreicht
	612 =	FEHLER NACHZIEHEN: Drehwinkel Überschritten, Drehmoment Ok
	613 =	FEHLER NACHZIEHEN: Timeout Nachziehdrehmoment konnte nicht erreicht werden
	614 =	FEHLER NACHZIEHEN: Timeout Drehmoment Ok, aber keinen Stillstand
	61 =	FEHLER NACHZIEHEN: Timeout kein Drehmoment und keinen Stillstand
	
	62 =	FEHLER SCHRAUBFALL: Weicher Schraubfall erkannt
	
	631 =	FEHLER NACHZIEHEN: Tiefe Unterschritten, Schiene fehlt
	632 =	FEHLER NACHZIEHEN: Tiefe nicht erreicht, Bohrung nicht tief genug
	63	=	FEHLER NACHZIEHEN: Undefinierter Fehler*)
(* ================================================================================ *)
	
CASE nStep OF
(*================================================================================================================*)
-45: (* === FEHLER: LANGSAME GESCHWINDIGKEIT === *)
	sStep := 'FEHLER: Langsame Geschwindigkeit wird nicht erreicht';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-50: (* === FEHLER: SCHRAUBTIEFE FÜR SOLLDREHZAHL === *)
	sStep := 'FEHLER: Timeout Schraubtiefe für Solldrehzahl wird nicht erreicht';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-60: (* === FEHLER:  === *)
	sStep := 'FEHLER EINDREHEN: Timeout kein Drehmoment und keinen Stillstand';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
(*================================================================================================================*)
-601: (* === FEHLER:  === *)
	sStep := 'FEHLER EINDREHEN: Drehwinkel überschritten';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-602: (* === FEHLER:  === *)
	sStep := 'FEHLER EINDREHEN: Drehmoment Ok aber nicht Tief genug';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-603: (* === FEHLER:  === *)
	sStep := 'FEHLER EINDREHEN: Timeout Drehmoment konnte nicht erreicht werden';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF		

(*================================================================================================================*)
-604: (* === FEHLER:  === *)
	sStep := 'FEHLER EINDREHEN: Timeout Drehmoment Ok, aber kein Stillstand';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-61: (* === FEHLER:  === *)		
	sStep := 'FEHLER NACHZIEHEN: Timeout kein Drehmoment und keinen Stillstand';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-611:  (* === FEHLER:  === *)	
	sStep := 'FEHLER NACHZIEHEN: Drehwinkel Überschritten, Drehmoment nicht erreicht';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF	
	
(*================================================================================================================*)
-612:  (* === FEHLER:  === *)	
	sStep := 'FEHLER NACHZIEHEN: Drehwinkel Überschritten, Drehmoment Ok';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF	

(*================================================================================================================*)
-613:  (* === FEHLER:  === *)	
	sStep := 'FEHLER NACHZIEHEN: Timeout Nachziehdrehmoment konnte nicht erreicht werden';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF	

(*================================================================================================================*)
-614:  (* === FEHLER:  === *)	
	sStep := 'FEHLER NACHZIEHEN: Timeout Drehmoment Ok, aber keinen Stillstand';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF	
	
(*================================================================================================================*)
-62: (* === FEHLER:  === *)	
	sStep := 'FEHLER SCHRAUBFALL: Weicher Schraubfall erkannt';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF

(*================================================================================================================*)
-63: (* === FEHLER:  === *)	
	sStep := 'FEHLER TIEFEPRÜFUNG: Undefinierter Fehler';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-631: (* === FEHLER:  === *)	
	sStep := 'FEHLER TIEFEPRÜFUNG: Tiefe Unterschritten, Schiene fehlt';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
(*================================================================================================================*)
-632: 
	sStep := 'FEHLER TIEFEPRÜFUNG: Tiefe nicht erreicht, Bohrung nicht tief genug';
	Q_nErrorId := nStep;
	
	IF I_bQuittFehler 
	THEN
		nStep := 100;	(* -> Beenden *)
	END_IF
	
END_CASE
	]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac_Hauptablauf" Id="{a7beba71-c765-4242-9292-6d5fa44c1eae}" FolderPath="Ablauf\">
      <Implementation>
        <ST><![CDATA[(*
================================================================================
HAUPTABLAUF - ZUSTANDSMASCHINE SERVOSCHRAUBER
================================================================================
Zentrale Zustandsmaschine mit deterministischem Ablauf.
Alle Schritte sind eindeutig nummeriert und kommentiert.
Watchdog-Timer überwachen kritische Phasen.
================================================================================
*)

tonTimeOver();
tonStillstand();

(*=== HAUPTZUSTANDSMASCHINE === *)
IF NOT I_bReset 
THEN
	CASE nStep OF
(*================================================================================================================*)	
	(* ================================================================================ *)
	(* INITIALISIERUNG UND BEREITSCHAFT *)
	(* ================================================================================ *)
(*================================================================================================================*)
	0: (* === INITIALISIERUNG === *)
		sStep := 'Initialisierung';
		bDone := FALSE;
		
		(* Drehmoment Vorgabe errechnen *)
		m_DrehmomentVorgabe(
			nSkalierung :=			I_stSchraubParam.nDrehmomentSkalierVorgabe,
			nTorque:= 				I_stSchraubParam.nDrehmomentSoll, 
			nRatedCurrentMotor:= 	I_stSchraubParam.nNennleistungMotor, 
			nTorqueConstant:= 		I_stSchraubParam.nDrehmomentKonstante, 
			bIndexIsOne :=			bScheitelEffektivwert,
			nTorqueLimitation=> 	nSollDrehmomentErrechnet);
			
		Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet); 
		
		IF I_bFreigabe
		THEN
			nStep := 10;
		END_IF
		
(*================================================================================================================*)
	10: (* === BEREITSCHAFT === *)
		sStep := 'Bereitschaft';
		tonTimeOver.IN := FALSE;
		tonStillstand.IN := FALSE;
		
		(* Drehmoment Vorgabe errechnen *)
		m_DrehmomentVorgabe(
			nSkalierung :=			I_stSchraubParam.nDrehmomentSkalierVorgabe,
			nTorque:= 				I_stSchraubParam.nDrehmomentSoll, (* Drehmoment erst Senken um Überdrehen zu verhinder *) 
			nRatedCurrentMotor:= 	I_stSchraubParam.nNennleistungMotor, 
			nTorqueConstant:= 		I_stSchraubParam.nDrehmomentKonstante, 
			bIndexIsOne :=			bScheitelEffektivwert,
			nTorqueLimitation=> 	nSollDrehmomentErrechnet);
			
		Q_nTorque := LREAL_TO_INT(nSollDrehmomentErrechnet); 
		bBusy							:= TRUE;
		
		IF I_bStart
			AND Q_nTorque <>0
		THEN
			(* Prozessdaten auf 0 setzen *)
			nPD_Tiefe						:= 0;			(* Prozessdaten - erreichte Tiefe *)
			nPD_Drehmoment					:= 0;			(* Prozessdaten - erreichtes Drehmoment *)
			nPD_Drehwinkel					:= 0;			(* Prozessdaten - erreichter Drehwinkel *)
			nPD_DrehwinkelAnzug				:= 0;			(* Prozessdaten - erreichter Drehwinkel beim Anzug*)
			iPD_Schraubfall					:= 0;			(* Prozessdaten - Schraubfall Undefiniert*)
			tPD_Schraubtakt					:= T#0S;		(* Prozessdaten - Zeit nur für den Schraubvorgang ohne Zylinder bewegungen etc. *)
			bPD_SchraubVorgOk				:= FALSE;		(* Prozessdaten - Schraubvorgang OK *)
			nDrehwinkelMem     				:= 0;
			bDrehmomOkMem					:= FALSE;
			bDrehwinkelOkMem				:= FALSE;
			bTiefeOkMem						:= FALSE;
			bTiefeStehtOkMem				:= FALSE;
			bSchraubStangeStehtOkMem		:= FALSE;
			bDrehwinkelTiefeOkMem			:= FALSE;
			nTiefeAbweichMem				:= 0;
			nFehlerSchrittMerker			:= 0;
			nTiefErrechnetMem				:= 0;
			nStep := 45;
		END_IF
		
(*================================================================================================================*)
	45: (* === ANLAUFPHASE - LANGSAME DREHZAHL === *)
		sStep := 'Anlaufphase_Langsam';
					
		(* Watchdog für Anlaufphase *)
		tonTimeOver.IN := TRUE;
		tonTimeOver.PT := T#200MS;
	
		(* Startdrehzahl setzen *)
		IF bDrehmomentEinrichten
		THEN
			m_DrehzahlVorgabe(
				lrMaxDrehzahl:=  		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw, 
				lrDrehzahlSollUpm:= 	nDrehzahlEinrichten, 
				lrDrehzahlVorgabe=> 	lrDrehzahlSollProzent);
		ELSE
			m_DrehzahlVorgabe(
				lrMaxDrehzahl:=  		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw, 
				lrDrehzahlSollUpm:= 	I_stSchraubParam.nDrehzahlSollAnfang, 
				lrDrehzahlVorgabe=> 	lrDrehzahlSollProzent);
		END_IF
		
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_nPTPVelo := lrDrehzahlSollProzent;
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_PTPBuffMode := MC_Aborting;
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := I_bFreigabe;
		
		(* Prüfung ob 80% der Sollgeschwindigkeit erreicht *)
		IF	IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_bFaehrtPos 
		    AND (((IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActVelo / IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw) * 100)
			     >= lrDrehzahlSollProzent * 0.8)
		THEN
			
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := FALSE;
			tonTimeOver.IN := FALSE;
			
			IF bDrehmomentEinrichten
			THEN
				nMaxAutoTestsDrehmom := 0;
				nDrehmomentEinrichten := nDrehmomentEinrichtenStart;
				nStep := 900;	(* -> Einrichtbetrieb für Drehmoment *)
			ELSE
				nStep := 50;	(* -> Hauptschraubphase *)
			END_IF
		
			
		ELSIF tonTimeOver.Q 
		THEN
			(* Timeout - Geschwindigkeit nicht erreicht *)
			tonTimeOver.IN := FALSE;
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -45;	(* Fehlercode merken *)
		END_IF
		
(*================================================================================================================*)
	50: (* === HAUPTSCHRAUBPHASE - GESCHWINDIGKEIT AUFBAUEN === *)
		sStep := 'Beschleunigungsphase';
		
		(* Watchdog für Beschleunigungsphase *)
		tonTimeOver.IN := TRUE;
		tonTimeOver.PT := T#300MS;
			
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := I_bFreigabe;
				
		(* Startdrehzahl setzen *)
		m_DrehzahlVorgabe(
			lrMaxDrehzahl:=  		IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw, 
			lrDrehzahlSollUpm:= 	I_stSchraubParam.nDrehzahlSoll, 
			lrDrehzahlVorgabe=> 	lrDrehzahlSollProzent);
			
		(* Umschaltung auf Solldrehzahl basierend auf Schraubtiefe *)
		IF I_bStart 
			AND fSchraubTiefeIst < I_stSchraubParam.nTiefeSollDrehzahl 
		THEN
			(* Vollschraubung *)
			tonTimeOver.IN := FALSE;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := FALSE;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_nPTPVelo := lrDrehzahlSollProzent;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_PTPBuffMode := MC_BlendingNext;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := I_bFreigabe;
			
			nAuswertungPosMem := IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActPos; (* Position Merken *)	
			
			(* Warten auf 80% der Soll Drehzahl aufgebaut, damit nicht versehentlich das Drehmoment schon beim beschleunigen erreicht wird *)
			IF	IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_bFaehrtPos 
		    AND (((IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActVelo / IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nParamEilgeschw) * 100)
			     >= lrDrehzahlSollProzent * 0.8)
			THEN	
				nStep := 60;
			END_IF
	
		ELSIF 
			tonTimeOver.Q 
		THEN
			(* Timeout - Solltiefe für Drehzahlumschaltung nicht erreicht *)
			tonTimeOver.IN := FALSE;
			nStep := 70;	(* -> Motor stoppen *)
			nFehlerSchrittMerker := -50;	(* Fehlercode merken *)
		END_IF
		
(*================================================================================================================*)
	60: (* === Drehmoment Auswertung === *) 
		ac_60_Eindrehen();		
		
(*================================================================================================================*)			
	61:	(* === Drehmoment Nachziehen === *) 
		ac_61_Nachziehen();	
		
(*================================================================================================================*)			
	62:	(* === Schraubfall Auswertung (Hart/Weich) === *) 
		ac_62_Schraubfall();
		
(*================================================================================================================*)			
	63:	(* === Tiefe prüfen === *) 
		ac_63_Tiefe();
		
(*================================================================================================================*)
	70: (* === MOTOR STOPPEN === *)
		sStep := 'Motor_Stoppen';
		Q_nTorque := 0;
		
		(* Watchdog für Stoppvorgang *)
		tonTimeOver.IN := TRUE;
		tonTimeOver.PT :=  T#20MS;
				
		(* Achse stoppen *)
		IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStoppen := TRUE;
		
		(* Warten auf Stillstand *)
		IF tonTimeOver.Q 
		   OR IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_bInPos
		THEN
			tonTimeOver.IN := FALSE;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStoppen := FALSE;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := FALSE;
			nStep := 75;	(* -> Stillstand abwarten *)
		END_IF
		
(*================================================================================================================*)
	75: (* === STILLSTAND ABWARTEN === *)
		sStep := 'Stillstand_Abwarten';
		
		(* Watchdog für Stillstand *)
		tonTimeOver.IN := TRUE;
		tonTimeOver.PT :=  T#2S;
		
		(* Warten auf Motorstillstand *)
		IF tonTimeOver.Q
			OR IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_bInStillstand
		THEN
			bAchsreset := TRUE;
			tonTimeOver.IN := FALSE;
			
			nStep := 80;
		END_IF

(*================================================================================================================*)
	80: (* === AUSWERTUNG FEHLERSCHRITTMERKER === *)
		sStep := 'Fehlerschritt auswerten';
		
		(* Fehler auswerten *)
		IF nFehlerSchrittMerker <> 0
		THEN
			nStep := nFehlerSchrittMerker;
		ELSE
			bPD_SchraubVorgOk := TRUE;
			nStep := 100;
		END_IF
				
(*================================================================================================================*)
	100: (* === VORGANG ERFOLGREICH BEENDET === *)
		sStep := 'Vorgang_OK';
		
		bBusy := FALSE;
		bDone := TRUE;
		
		(* Warten auf Freigabe für nächsten Zyklus *)
		IF NOT I_bStart 
		THEN
			Q_nTorque := 300;	
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bSteuerwortBit1	:= FALSE;
			IQ_SchrauberAchsStruc_InOut.NC_Axis_OUT_bAchsePosStarten := FALSE;
			nStep := 0;	(* -> Zurück zur Bereitschaft *)
		END_IF
		

		
	END_CASE
	
ELSE
	(* === RESET AKTIV === *)
	nStep := 0;
END_IF

(*========================================================*)
(* Prozessdaten Merker schreiben *)
(*========================================================*)
IF (nStep >= 55)
	AND (nStep <= 70)
THEN
	
	(* Prozessdaten Tiefe Schreiben *)
	IF fSchraubTiefeIst < nPD_Tiefe
	THEN
		nPD_Tiefe:=	fSchraubTiefeIst;
	END_IF
	(* Prozessdaten Drehmoment Schreiben *)
	IF fDrehmomentIstMittel >nPD_Drehmoment
	THEN
		nPD_Drehmoment :=	fDrehmomentIstMittel;
	END_IF
	
END_IF

(*========================================================*)
(* Prozessdaten Struktur schreiben *)
(*========================================================*)
Q_stProzessDaten.nPD_Drehmoment				:=	nPD_Drehmoment;
Q_stProzessDaten.nPD_Drehwinkel				:=	nPD_Drehwinkel;
Q_stProzessDaten.nPD_DrehwinkelAnzug		:=	nPD_DrehwinkelAnzug;
Q_stProzessDaten.nPD_Tiefe					:=	nPD_Tiefe;
Q_stProzessDaten.tPD_Schraubtakt			:=	tPD_Schraubtakt;
Q_stProzessDaten.iPD_Schraubfall			:=	iPD_Schraubfall;
Q_stProzessDaten.bPD_SchraubVorgOk			:=	bPD_SchraubVorgOk;
Q_stProzessDaten.bPD_DrehmomOk				:=	bDrehmomOkMem;
Q_stProzessDaten.bPD_DrehwinkelOk			:=	bDrehwinkelOkMem;
Q_stProzessDaten.bPD_TiefeOk				:=	bTiefeOkMem;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ac99_Doku" Id="{4b2e4e7e-3f57-4148-b830-7a58c66f56ce}">
      <Implementation>
        <ST><![CDATA[(*
# Dokumentation: fb_SKSSchraubNob

**Funktion:** Servoschrauber-Prozessbaustein für Schubkastenschienen (Nobilia-Vorgabe).

Dieser Baustein steuert den reinen Schraubprozess über eine NC-Achse. Er übernimmt die Ansteuerung des Motors und die Überwachung von Drehmoment, 
Drehwinkel und Schraubtiefe. Periphere Funktionen wie Pneumatik oder die Schraubenzuführung sind bewusst nicht Teil dieses Bausteins, um eine einfache Integration in bestehende, übergeordnete Steuerungen zu ermöglichen.

**Version:** 4.02  
**Zielsetzung:** Ein schneller und präziser Schraubvorgang (typ. 500–650 ms) mit zuverlässiger Erkennung des Schraubergebnisses und klarer Fehlerdiagnose.

---

## 1. Funktionsprinzip und Ablauf

Der Baustein arbeitet als Zustandsmaschine (Schrittkette), die den Schraubvorgang in klar definierte Phasen unterteilt. Jede kritische Phase wird von einem Zeitwächter (Watchdog) überwacht, um bei Problemen einen definierten Abbruch zu gewährleisten.

**Der Prozess gliedert sich in folgende Hauptschritte:**

1.  **Initialisierung und Bereitschaft:**
    *   Der Baustein wartet auf die Freigabe und das Startsignal.
    *   Eine grundlegende Drehmomentbegrenzung wird aktiviert und interne Prozessdaten werden zurückgesetzt.

2.  **Anlaufphase (langsame Drehzahl):**
    *   Der Motor startet mit einer niedrigen Drehzahl, um die Schraube sicher anzusetzen.
    *   Der Ablauf geht weiter, sobald die Schraube sicher dreht (ca. 80 % der Zieldrehzahl sind erreicht). Andernfalls wird ein Timeout-Fehler ausgelöst.

3.  **Hauptschraubphase (Beschleunigen):**
    *   Die Drehzahl wird auf die volle Prozessgeschwindigkeit erhöht, um Strecke zu machen.
    *   Diese Phase endet, sobald eine vordefinierte Schraubtiefe erreicht ist.

4.  **Drehzahlreduzierung (Anzugsphase):**
    *   Kurz vor dem erwarteten Anzugsmoment wird die Drehzahl reduziert. Dies ermöglicht eine präzisere Erfassung des Zieldrehmoments.
    *   Der Schritt wird auch eingeleitet, falls das Drehmoment unerwartet früh ansteigt.

5.  **Warten auf Zieldrehmoment:**
    *   Der Baustein überwacht nun das Motordrehmoment.
    *   Sobald das Zieldrehmoment erreicht ist, wird die nächste Stufe der Auswertung eingeleitet.
    *   Optional wird parallel der Drehwinkel überwacht, um ein "Überdrehen" (z. B. bei fehlendem Material) frühzeitig zu erkennen.

6.  **Finale Auswertung (Drehmoment, Drehwinkel & Stillstand):**
    *   **Optional:** Um den Schraubfall sicher zu klassifizieren, kann die Drehmomentvorgabe kurzzeitig erhöht werden. Dies erzwingt ein minimales Weiterdrehen und liefert klarere Sensorsignale.
    *   Es wird geprüft, ob der zusätzliche Drehwinkel nach Erreichen des Zieldrehmoments in einem engen Fenster bleibt.
    *   Gleichzeitig wird überwacht, ob die Schrauberachse zum Stillstand kommt.
    *   Sind beide Kriterien (Winkel im Fenster & Stillstand) erfüllt, war der Anzug erfolgreich.

7.  **Schraubfallprüfung (hart/weich):**
    *   Unmittelbar nach dem Stillstand wird die Tiefenänderung analysiert.
    *   Bleibt die Tiefe konstant, liegt ein **harter Schraubfall** vor (erwartet bei Metall auf Holz).
    *   Ändert sich die Tiefe weiter, deutet dies auf einen **weichen Schraubfall** hin (z. B. Setzverhalten, fehlende Schiene) und löst einen Fehler oder optional einen Nachziehversuch aus.

8.  **Finale Tiefenprüfung (optional):**
    *   Abschließend wird kontrolliert, ob die erreichte Endtiefe innerhalb der vorgegebenen Toleranz liegt.

9.  **Abschluss:**
    *   Der Motor wird definiert gestoppt und die Drehmomentvorgabe auf null gesetzt.
    *   Wenn alle Prüfungen erfolgreich waren, wird der Prozess als "erfolgreich" (`Done`) markiert.
    *   Im Fehlerfall wird ein spezifischer Fehlercode ausgegeben.
    *   Nachdem das Startsignal zurückgenommen wird, geht der Baustein wieder in die Bereitschaft.
	
## 2. Wichtige Parameter (`I_stSchraubParam`)

-   `nDrehmomentSoll`: Das **Zieldrehmoment**, bei dem der Anzug als erreicht gilt.
-   `nDrehzahlSoll...`: Drei Drehzahlen für die Phasen **Anlauf**, **Hauptschrauben** und **Anziehen (Ende)**.
-   `nTiefe...Drehzahl`: Schraubtiefen, bei denen von einer Drehzahlstufe zur nächsten gewechselt wird.
-   `nSchraubtiefeSoll` / `...Toleranz`: Die **Zieldrehtiefe** mit ihrem Toleranzfenster.
-   `nMaxDrehwinkelNachDrehmOk`: Der **maximal erlaubte Drehwinkel**, *nachdem* das Zieldrehmoment erreicht wurde. Ein kritisches Fenster zur Qualitätsbewertung.
-   `t...Timeout` / `...Zeit`: Diverse **Zeitüberwachungen** für die einzelnen Prozessphasen.

---

## 3. Interne Logik und Konfiguration

Mehrere interne `BOOL`-Variablen (Schalter) ermöglichen ein Feintuning des Ablaufs, ohne den Code zu ändern:

-   `bDrehmomentErhoehNachDrehmomOk` (Standard: `TRUE`):
    Aktiviert die kurzzeitige Erhöhung der Drehmomentvorgabe nach Erreichen des Ziels. **Empfohlen für eine stabile Schraubfallerkennung.**
-   `bSchraubfallAuswertung` (Standard: `TRUE`):
    Aktiviert die Prüfung auf einen harten/weichen Schraubfall mittels Tiefenanalyse.
-   `bTiefenAuswertung` (Standard: `TRUE`):
    Aktiviert die finale, reine Prüfung der Endtiefe.
-   `bNachziehenBeiSchraubfallWeich` (Standard: `FALSE`):
    Ermöglicht einen automatischen Nachziehversuch, wenn ein weicher Schraubfall erkannt wird.

---

## 4. Fehlercodes und ihre Bedeutung

-   `-45`: **Anlauf zu langsam:** Die Startdrehzahl wurde nicht schnell genug erreicht.
-   `-50` / `-51`: **Timeout bei Drehzahlumschaltung:** Die erwartete Schraubtiefe für den nächsten Drehzahlschritt wurde nicht erreicht.
-   `-55`: **Timeout bei Drehmomenterkennung:** Das Zieldrehmoment wurde nicht innerhalb der erwarteten Zeit erreicht.
-   `-551`: **Drehwinkel überschritten (vor Drehmoment-OK):** Die Schraube dreht zu weit, ohne dass das Drehmoment ansteigt.
-   `-61` / `-1261`: **Fehler in der finalen Auswertung:** Der Drehwinkel war zu groß, oder die Achse kam nicht zum Stillstand.
-   `-62`: **Weicher Schraubfall erkannt:** Die Tiefe hat sich nach dem Anziehen noch verändert (z. B. Material setzt sich, Schiene fehlt).
-   `-631` / `-632`: **Endtiefe außerhalb der Toleranz:** Schraube zu flach oder zu tief.
-   `-301`: **Fehler bei Leerlaufprüfung:** Die Mechanik ist möglicherweise schwergängig.
*)]]></ST>
      </Implementation>
    </Action>
    <Method Name="m_Ausgangszuweisung" Id="{74c01e09-c989-4b6c-9bb0-bfec5129497b}" FolderPath="Methoden\Ausgang\">
      <Declaration><![CDATA[METHOD m_Ausgangszuweisung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
AUSGANGSZUWEISUNG
================================================================================
Zentrale Zuweisung aller Ausgangssignale mit Sicherheitsverriegelung
durch Schutzbereich und Reset-Zustand
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// === HAUPTSTATUS-AUSGÄNGE ===
Q_bBusy		:= bBusy;				(* Beschäftigt wenn nicht in Bereitschaft *)

Q_bDone		:= bDone;		(* Fertig bei Schritt 100 *)

// === ACHSEN-STEUERUNG ===
Q_bAxisReset := bAchsreset;

// === DIAGNOSE-AUSGÄNGE ===
Q_sState	:= sStep(*CONCAT(INT_TO_STRING(nStep), CONCAT(' - ', sStep))*);

Q_bSchrHalt := (nStep = 70);

(* Fehler allgemein *)
Q_bError	:= nStep<0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentMittelwert" Id="{77f39372-f3e1-4000-849a-5801781248c7}" FolderPath="Methoden\Drehmoment\">
      <Declaration><![CDATA[METHOD m_DrehmomentMittelwert : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
DREHMOMENT-MITTELWERTBILDUNG
================================================================================
Berechnet den gleitenden Mittelwert des Drehmoments über 10 Werte
zur Vermeidung von Fehlauslösungen durch kurze Spitzen.
================================================================================
*)
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === MITTELWERTBILDUNG NUR WÄHREND DREHMOMENTPRÜFUNG ===
IF (nStep >= 51 
	AND nStep <= 70) 
	OR nStep =301
	OR nStep =900
	OR nStep =901
	OR nStep =902
	OR nStep =903
THEN
	m_DrehmomentRechnung(
		nTorqueActValue:= 		INT_TO_LREAL(IQ_SchrauberAchsStruc_InOut.NC_Axis_IN_nActTorque), 
		nRatedCurrentMotor:=	I_stSchraubParam.nNennleistungMotor , 	
		nTorqueConstant:= 		I_stSchraubParam.nDrehmomentKonstante, 
		bIndexIsOne :=			bScheitelEffektivwert,
		nActTorqueCalc=> 		arrDrehmomentIst[0]);
	
	// Array nach rechts verschieben (Ringpuffer)
	FOR idx := 5 TO 1 BY -1 DO
		arrDrehmomentIst[idx] := arrDrehmomentIst[idx-1];
	END_FOR
	
	// Mittelwert über alle 10 Werte berechnen
	fDrehmomentIstMittel := (arrDrehmomentIst[1] 
						   + arrDrehmomentIst[2] 
						   + arrDrehmomentIst[3] 
						   + arrDrehmomentIst[4] 
						   + arrDrehmomentIst[5] (*
						   + arrDrehmomentIst[6] 
						   + arrDrehmomentIst[7] 
						   + arrDrehmomentIst[8] 
						   + arrDrehmomentIst[9] 
						   + arrDrehmomentIst[10]*)) / 5;
ELSE
	fDrehmomentIstMittel := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentPruefung" Id="{b15c2951-703a-4b2e-94f4-6e1a127b2d05}" FolderPath="Methoden\Pruefung\">
      <Declaration><![CDATA[METHOD m_DrehmomentPruefung : BOOL
VAR_INPUT
	nDrehmomentSoll		:LREAL;				
END_VAR
VAR_OUTPUT
	bDrehmomentOk		:BOOL;
END_VAR
(*
================================================================================
DrehmomentPruefung
================================================================================
Berechnet den gleitenden Mittelwert des Drehmoments über 10 Werte
zur Vermeidung von Fehlauslösungen durch kurze Spitzen.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fDrehmomentIstMittel >= 
	nDrehmomentSoll
THEN
	bDrehmomentOk := TRUE;	(* -> Drehmoment erreicht *)
ELSE
	bDrehmomentOk := FALSE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentRechnung" Id="{1bbcef17-e04b-4f43-82fa-b98e6a4d6400}" FolderPath="Methoden\Rechner\">
      <Declaration><![CDATA[METHOD m_DrehmomentRechnung : BOOL
VAR_INPUT
	
	
	nTorqueActValue		:LREAL;	
	
	nRatedCurrentMotor	:LREAL;	(*0x8011:12	*)
	nTorqueConstant		:LREAL;	(*0x8011:16	*)
	bIndexIsOne			: BOOL;		(* TRUE, wenn Index 0x8010:54 = 1, sonst FALSE *)
END_VAR
VAR_OUTPUT
	nActTorqueCalc		:LREAL;
END_VAR
VAR
	nEffectiveCurrent	: LREAL;
END_VAR
(*Achtung dies aus der Original Beckhoff Doku:

Anzeige des aktuellen Drehmomentwertes
Der Wert wird in 1000stel vom rated current (0x8011:12
[} 151]) angegeben
Formel für Index 0x8010:54 [} 148] = 0 :
M = ((Torque actual value / 1000) x (rated current /
√2)) x torque constant (0x8011:16 [} 151])
Formel für Index 0x8010:54 [} 148] = 1 :
M = ((Torque actual value / 1000) x rated current)) x
torque constant (0x8011:16 [} 151])*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bIndexIsOne THEN
	// Fall für Index = 1: Es wird der Nennstrom (rated current) verwendet
	nEffectiveCurrent := nRatedCurrentMotor;
ELSE
	// Fall für Index = 0: Es wird der Effektivstrom (rated current / √2) verwendet
	nEffectiveCurrent := nRatedCurrentMotor / 1.41421356237; // SQRT(2) für höhere Genauigkeit
END_IF;

nActTorqueCalc := ((nTorqueActValue / 1000) * nEffectiveCurrent) * nTorqueConstant;

(* OLD 
nActTorqueCalc:=	
(((nTorqueActValue/1000) * (nRatedCurrentMotor / 1.4142))* nTorqueConstant);	*)	(* Wurzel ziehen am besten einmalig bei Startup *)
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehmomentVorgabe" Id="{334d5570-7cec-4c2d-8d0e-4201a4c66404}" FolderPath="Methoden\Rechner\">
      <Declaration><![CDATA[METHOD m_DrehmomentVorgabe : BOOL
VAR_INPUT
	nSkalierung			: LREAL;	(* Zusätzlicher Skalierungsfaktor *)
	nTorque				: LREAL;	(* Eingang Soll-Drehmoment in Nm *)
	
	nRatedCurrentMotor	: LREAL;	(* 0x8011:12 *)
	nTorqueConstant		: LREAL;	(* 0x8011:16 *)
	
	bIndexIsOne			: BOOL;		(* TRUE, wenn Index 0x8010:54 = 1, sonst FALSE *)
END_VAR
VAR_OUTPUT
	nTorqueLimitation	: LREAL;	(* Berechneter Sollwert für den Antrieb *)
END_VAR
VAR
	nDivisor			: LREAL;
END_VAR

(*Achtung dies aus der Original Beckhoff Doku:

Anzeige des aktuellen Drehmomentwertes
Der Wert wird in 1000stel vom rated current (0x8011:12
[} 151]) angegeben
Formel für Index 0x8010:54 [} 148] = 0 :
M = ((Torque actual value / 1000) x (rated current /
√2)) x torque constant (0x8011:16 [} 151])
Formel für Index 0x8010:54 [} 148] = 1 :
M = ((Torque actual value / 1000) x rated current)) x
torque constant (0x8011:16 [} 151])*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF bIndexIsOne THEN
	// Fall für Index = 1: Divisor ist rated current
	nDivisor := nRatedCurrentMotor;
ELSE
	// Fall für Index = 0: Divisor ist rated current / √2
	nDivisor := nRatedCurrentMotor / 1.41421356237; // SQRT(2) für höhere Genauigkeit
END_IF;

// Plausibilitätsprüfung, um eine Division durch Null zu vermeiden
IF nTorqueConstant > 0 AND nDivisor > 0 THEN
	nTorqueLimitation := ((nTorque / nTorqueConstant) / nDivisor) * 1000 * nSkalierung;
ELSE
	nTorqueLimitation := 0;
END_IF;

(*OLD
nTorqueLimitation := ((nTorque / nTorqueConstant) / (nRatedCurrentMotor / 1.4142)) * 1000 *nSkalierung;*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehwinkelPruefung" Id="{f7872583-c9f4-4570-9dc0-fe102e0e693a}" FolderPath="Methoden\Pruefung\">
      <Declaration><![CDATA[METHOD m_DrehwinkelPruefung : BOOL
VAR_INPUT
	nPosAct		:LREAL;	(* Aktuelle Position  *)
	nPosMem		:LREAL;	(* Gespeicherte Position *)
	nMaxDrehwinkel	:LREAL;
	
END_VAR
VAR_OUTPUT
	bWinkelOk			:BOOL;
	nWinkelAct	:LREAL;
END_VAR
VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[nWinkelAct :=	nPosAct-nPosMem;

bWinkelOk :=	 nWinkelAct < nMaxDrehwinkel;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_DrehzahlVorgabe" Id="{d8955cdf-71ce-4acf-ba19-552d62bfa9a7}" FolderPath="Methoden\Rechner\">
      <Declaration><![CDATA[METHOD m_DrehzahlVorgabe 
VAR_INPUT
	lrMaxDrehzahl		:LREAL;		(* Drhezahl Eilgeschwindigkeit in Grad/ sec *)
	lrDrehzahlSollUpm	:LREAL;		(* Drehzahl Soll in Upm *)
END_VAR
VAR
	lrDrehzahlMem		:LREAL;
	
END_VAR
VAR_OUTPUT
	lrDrehzahlVorgabe	:LREAL;			(* Soll Drehzahl in % von 100 % *)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[lrDrehzahlMem := lrMaxDrehzahl /360 *60;

IF lrDrehzahlMem <> 0
THEN
	lrDrehzahlVorgabe :=	lrDrehzahlSollUpm / lrDrehzahlMem *100;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_SchraubtaktMessung" Id="{0bd72a6b-78b6-4b56-acc0-b6d291daa095}" FolderPath="Methoden\Diagnose\">
      <Declaration><![CDATA[METHOD m_SchraubtaktMessung : BOOL
VAR_INPUT
END_VAR
(*
================================================================================
SCHRAUBTAKT-ZEITMESSUNG
================================================================================
Misst die Schraubzeit für Diagnose und Optimierung.
Die Zeitmessung erfolgt während der aktiven Schraubphase.
================================================================================
*)]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* Komplett wird nicht verwendet, da ausgelagert in dem Übergeordneten Schrauberbaustein *)

(* Zeitmessung Schruabvorgang *)
fbtimeDiff_Schraub(
	bStart:= 		(nStep =45),	 
	bStop:= 		(nStep =80), 
	bReset:= 		(nStep =10),
	tDiffTime=> 	tPD_Schraubtakt);

	
fbtimeDiff_Step45(
	bStart:= 			nStep =45, 
	bStop:= 			nStep <>45, 
	bReset:= 			nStep = 10);

fbtimeDiff_Step50(
	bStart:= 			nStep =50, 
	bStop:= 			nStep <>50, 
	bReset:= 			nStep = 10);
	
fbtimeDiff_Step60(
	bStart:= 			nStep =60, 
	bStop:= 			nStep <>60, 
	bReset:= 			nStep = 10);
	
fbtimeDiff_Step45(
	bStart:= 			nStep =45, 
	bStop:= 			nStep <>45, 
	bReset:= 			nStep = 10);
	
fbtimeDiff_Step61(
	bStart:= 			nStep =61, 
	bStop:= 			nStep <>61, 
	bReset:= 			nStep = 10);
	
fbtimeDiff_Step62(
	bStart:= 			nStep =62, 
	bStop:= 			nStep <>62, 
	bReset:= 			nStep = 10);

fbtimeDiff_Step63(
	bStart:= 			nStep =62, 
	bStop:= 			nStep <>63, 
	bReset:= 			nStep = 10);
	
fbtimeDiff_Step70(
	bStart:= 			nStep =70, 
	bStop:= 			nStep <>70, 
	bReset:= 			nStep = 10);

fbtimeDiff_Step75(
	bStart:= 			nStep =75, 
	bStop:= 			nStep <>75, 
	bReset:= 			nStep = 10);	
	
(* Zeiten Schreiben *)
rTrigZeitenSchreiben(CLK:= (nStep =80));

IF rTrigZeitenSchreiben.Q
THEN
	stArraySteps[1] :=	CONCAT('Step_45_LangsamEin: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step45.tDiffTime )));
	stArraySteps[2] :=	CONCAT('Step_50_Beschleunigen auf SollDrehzahl: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step50.tDiffTime )));
	stArraySteps[3] :=	CONCAT('Step_60_Warten Aufdrehmoment: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step60.tDiffTime )));
	stArraySteps[4] :=	CONCAT('Step_61_Nachziehen auf Winkel: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step61.tDiffTime )));
	stArraySteps[5] :=	CONCAT('Step_62_Auswertung Tiefenänderung: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step62.tDiffTime )));
	stArraySteps[6] :=	CONCAT('Step_63_Auswertung Tiefe: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step63.tDiffTime )));
	stArraySteps[7] :=	CONCAT('Step_70_Motor anhalten: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step70.tDiffTime )));
	stArraySteps[8] :=	CONCAT('Step_75_Warte auf Motor Steht: ', INT_TO_STRING(TIME_TO_INT(fbtimeDiff_Step75.tDiffTime )));
	stArraySteps[9] :=	'';
	stArraySteps[10] := '';
	
	tGesamtZeit:=	fbtimeDiff_Step45.tDiffTime
					+	fbtimeDiff_Step50.tDiffTime
					+	fbtimeDiff_Step60.tDiffTime
					+	fbtimeDiff_Step61.tDiffTime
					+	fbtimeDiff_Step62.tDiffTime
					+	fbtimeDiff_Step63.tDiffTime
					+	fbtimeDiff_Step70.tDiffTime
					+	fbtimeDiff_Step75.tDiffTime;
					
	sGesamtZeit :=		CONCAT('GesamtZeit: ', INT_TO_STRING(TIME_TO_INT(tGesamtZeit )));
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_StillstandPruef" Id="{78e76abc-3570-46f3-b0f9-5b0c754e0a13}" FolderPath="Methoden\Pruefung\">
      <Declaration><![CDATA[METHOD m_StillstandPruef 
VAR_INPUT
	nIstDrehzahl	:LREAL;
	nMinDrehzahl	:LREAL;
END_VAR
VAR_OUTPUT
	bSteht			:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[



IF ABS(nIstDrehzahl) < ABS(nMinDrehzahl) 
THEN
	bSteht := TRUE;
ELSE
	bSteht := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_TiefenAenderung" Id="{4331bc38-e923-4719-8891-74280cf938a9}" FolderPath="Methoden\Pruefung\">
      <Declaration><![CDATA[METHOD m_TiefenAenderung
VAR_INPUT
	nTiefeStreckeIst				:LREAL;
	nDrehwinkelIst					:LREAL;
	nSteigungSchraube				:LREAL := 1.6;	(* Tiefe pro umdrehung *)
	nAbweichung						:LREAL := 25;	(* in Prozent *)
	nMinStrecke						:LREAL := 0.1;
END_VAR
VAR_OUTPUT
	nProzentAbweichung 				:LREAL;	(* Nur zu Diagnosezwecken *)
	nTiefeErrechnet					:LREAL;	(* Nur zu Diagnosezwecken *)
	bTiefeSteht						:BOOL;
END_VAR
VAR
	nDelta             : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF nSteigungSchraube  > 0
	AND nAbweichung > 0
THEN

	IF nTiefeStreckeIst< nMinStrecke
	THEN
		 bTiefeSteht := TRUE;
		 
	ELSE
		nTiefeErrechnet :=	ABS(nDrehwinkelIst /360* nSteigungSchraube);
	
		nDelta := ABS(nTiefeErrechnet - nTiefeStreckeIst);
		
		IF nTiefeStreckeIst <> 0.0 THEN
			nProzentAbweichung := nDelta / ABS(nTiefeStreckeIst) * 100.0;
		ELSE
			nProzentAbweichung := 0.0;
		END_IF
		
		
		IF nProzentAbweichung >= nAbweichung THEN
			bTiefeSteht := TRUE;
		ELSE
			bTiefeSteht := FALSE;
		END_IF
	END_IF
ELSE
    bTiefeSteht := FALSE;
    nTiefeErrechnet := 0.0;
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="m_TiefenPruefung" Id="{a103558d-0397-404b-aa38-f8b16ef7498c}" FolderPath="Methoden\Pruefung\">
      <Declaration><![CDATA[METHOD m_TiefenPruefung : BOOL
VAR_INPUT
	nSolltiefe	:LREAL;
	nToleranz	:LREAL;
	nActTiefe	:LREAL;
END_VAR
VAR_OUTPUT
	bTiefeOk	:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Prüfung der Aufsetztiefe
IF F_Inbetween(
	I_fActualValue := nActTiefe,
	I_fMinimalValue := nSolltiefe - nToleranz,		(* Sollaufsetztiefe ± Toleranz *)
	I_fMaximalValue := nSolltiefe + nToleranz) 
THEN
	bTiefeOk := TRUE;
ELSE
	bTiefeOk := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="fb_SKSSchraubNob">
      <LineId Id="9" Count="0" />
      <LineId Id="457" Count="0" />
      <LineId Id="299" Count="0" />
      <LineId Id="298" Count="0" />
      <LineId Id="461" Count="0" />
      <LineId Id="729" Count="0" />
      <LineId Id="726" Count="0" />
      <LineId Id="452" Count="0" />
      <LineId Id="450" Count="0" />
      <LineId Id="462" Count="1" />
      <LineId Id="454" Count="0" />
      <LineId Id="464" Count="0" />
      <LineId Id="455" Count="0" />
      <LineId Id="439" Count="0" />
      <LineId Id="503" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_60_Eindrehen">
      <LineId Id="2" Count="12" />
      <LineId Id="21" Count="1" />
      <LineId Id="71" Count="5" />
      <LineId Id="79" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="34" Count="1" />
      <LineId Id="114" Count="3" />
      <LineId Id="113" Count="0" />
      <LineId Id="166" Count="5" />
      <LineId Id="118" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="36" Count="1" />
      <LineId Id="130" Count="3" />
      <LineId Id="129" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="125" Count="1" />
      <LineId Id="150" Count="7" />
      <LineId Id="159" Count="4" />
      <LineId Id="128" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="57" Count="2" />
      <LineId Id="61" Count="4" />
      <LineId Id="89" Count="0" />
      <LineId Id="94" Count="2" />
      <LineId Id="98" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="99" Count="4" />
      <LineId Id="105" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="106" Count="1" />
      <LineId Id="111" Count="1" />
      <LineId Id="110" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="84" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_61_Nachziehen">
      <LineId Id="63" Count="0" />
      <LineId Id="331" Count="1" />
      <LineId Id="342" Count="0" />
      <LineId Id="333" Count="1" />
      <LineId Id="254" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="409" Count="0" />
      <LineId Id="5" Count="2" />
      <LineId Id="9" Count="0" />
      <LineId Id="410" Count="0" />
      <LineId Id="412" Count="0" />
      <LineId Id="287" Count="0" />
      <LineId Id="343" Count="5" />
      <LineId Id="296" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="11" Count="5" />
      <LineId Id="18" Count="2" />
      <LineId Id="265" Count="0" />
      <LineId Id="263" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="279" Count="0" />
      <LineId Id="195" Count="2" />
      <LineId Id="193" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="198" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="190" Count="2" />
      <LineId Id="417" Count="0" />
      <LineId Id="416" Count="0" />
      <LineId Id="413" Count="0" />
      <LineId Id="251" Count="0" />
      <LineId Id="415" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="368" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="252" Count="1" />
      <LineId Id="266" Count="0" />
      <LineId Id="369" Count="0" />
      <LineId Id="267" Count="1" />
      <LineId Id="270" Count="0" />
      <LineId Id="269" Count="0" />
      <LineId Id="370" Count="0" />
      <LineId Id="280" Count="1" />
      <LineId Id="285" Count="0" />
      <LineId Id="283" Count="1" />
      <LineId Id="282" Count="0" />
      <LineId Id="272" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="371" Count="0" />
      <LineId Id="260" Count="0" />
      <LineId Id="262" Count="0" />
      <LineId Id="59" Count="1" />
      <LineId Id="85" Count="0" />
      <LineId Id="349" Count="0" />
      <LineId Id="372" Count="0" />
      <LineId Id="438" Count="0" />
      <LineId Id="367" Count="0" />
      <LineId Id="350" Count="1" />
      <LineId Id="373" Count="0" />
      <LineId Id="363" Count="0" />
      <LineId Id="374" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="356" Count="0" />
      <LineId Id="375" Count="0" />
      <LineId Id="380" Count="0" />
      <LineId Id="431" Count="0" />
      <LineId Id="381" Count="0" />
      <LineId Id="439" Count="0" />
      <LineId Id="353" Count="0" />
      <LineId Id="419" Count="3" />
      <LineId Id="432" Count="0" />
      <LineId Id="423" Count="1" />
      <LineId Id="428" Count="0" />
      <LineId Id="433" Count="0" />
      <LineId Id="429" Count="0" />
      <LineId Id="418" Count="0" />
      <LineId Id="352" Count="0" />
      <LineId Id="341" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="382" Count="0" />
      <LineId Id="437" Count="0" />
      <LineId Id="384" Count="1" />
      <LineId Id="389" Count="0" />
      <LineId Id="386" Count="0" />
      <LineId Id="399" Count="0" />
      <LineId Id="434" Count="0" />
      <LineId Id="390" Count="0" />
      <LineId Id="393" Count="3" />
      <LineId Id="401" Count="0" />
      <LineId Id="435" Count="0" />
      <LineId Id="397" Count="0" />
      <LineId Id="402" Count="0" />
      <LineId Id="408" Count="0" />
      <LineId Id="436" Count="0" />
      <LineId Id="406" Count="0" />
      <LineId Id="387" Count="0" />
      <LineId Id="213" Count="0" />
      <LineId Id="211" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_62_Schraubfall">
      <LineId Id="30" Count="0" />
      <LineId Id="73" Count="3" />
      <LineId Id="78" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="2" Count="8" />
      <LineId Id="81" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="87" Count="0" />
      <LineId Id="117" Count="2" />
      <LineId Id="124" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="58" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="18" Count="3" />
      <LineId Id="72" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="85" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_63_Tiefe">
      <LineId Id="30" Count="1" />
      <LineId Id="82" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="2" Count="3" />
      <LineId Id="57" Count="4" />
      <LineId Id="12" Count="4" />
      <LineId Id="18" Count="3" />
      <LineId Id="25" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="67" Count="4" />
      <LineId Id="73" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="76" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_AutoTest">
      <LineId Id="2" Count="8" />
      <LineId Id="363" Count="1" />
      <LineId Id="362" Count="0" />
      <LineId Id="369" Count="0" />
      <LineId Id="11" Count="25" />
      <LineId Id="39" Count="6" />
      <LineId Id="140" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="51" Count="6" />
      <LineId Id="273" Count="12" />
      <LineId Id="360" Count="0" />
      <LineId Id="286" Count="0" />
      <LineId Id="295" Count="1" />
      <LineId Id="71" Count="7" />
      <LineId Id="138" Count="0" />
      <LineId Id="80" Count="1" />
      <LineId Id="110" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="266" Count="5" />
      <LineId Id="297" Count="25" />
      <LineId Id="353" Count="5" />
      <LineId Id="352" Count="0" />
      <LineId Id="359" Count="0" />
      <LineId Id="323" Count="8" />
      <LineId Id="371" Count="1" />
      <LineId Id="374" Count="0" />
      <LineId Id="373" Count="0" />
      <LineId Id="370" Count="0" />
      <LineId Id="332" Count="4" />
      <LineId Id="361" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="348" Count="0" />
      <LineId Id="351" Count="0" />
      <LineId Id="347" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_Fehler">
      <LineId Id="165" Count="23" />
      <LineId Id="164" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="5" Count="158" />
      <LineId Id="4" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac_Hauptablauf">
      <LineId Id="4794" Count="11" />
      <LineId Id="5357" Count="0" />
      <LineId Id="4806" Count="33" />
      <LineId Id="5358" Count="0" />
      <LineId Id="4840" Count="44" />
      <LineId Id="5359" Count="1" />
      <LineId Id="5368" Count="2" />
      <LineId Id="5367" Count="0" />
      <LineId Id="5362" Count="0" />
      <LineId Id="5364" Count="2" />
      <LineId Id="5363" Count="0" />
      <LineId Id="5361" Count="0" />
      <LineId Id="4888" Count="0" />
      <LineId Id="4890" Count="14" />
      <LineId Id="5372" Count="0" />
      <LineId Id="5371" Count="0" />
      <LineId Id="4905" Count="42" />
      <LineId Id="5354" Count="0" />
      <LineId Id="5347" Count="2" />
      <LineId Id="5346" Count="0" />
      <LineId Id="4948" Count="0" />
      <LineId Id="5352" Count="1" />
      <LineId Id="4949" Count="93" />
      <LineId Id="5103" Count="0" />
      <LineId Id="5230" Count="40" />
      <LineId Id="1628" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.ac99_Doku">
      <LineId Id="293" Count="0" />
      <LineId Id="521" Count="57" />
      <LineId Id="649" Count="0" />
      <LineId Id="613" Count="35" />
      <LineId Id="520" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_Ausgangszuweisung">
      <LineId Id="30" Count="2" />
      <LineId Id="78" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="44" Count="1" />
      <LineId Id="63" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="75" Count="2" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_DrehmomentMittelwert">
      <LineId Id="13" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="78" Count="2" />
      <LineId Id="37" Count="0" />
      <LineId Id="48" Count="3" />
      <LineId Id="77" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="17" Count="18" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_DrehmomentPruefung">
      <LineId Id="10" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="24" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_DrehmomentRechnung">
      <LineId Id="75" Count="7" />
      <LineId Id="73" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_DrehmomentVorgabe">
      <LineId Id="59" Count="0" />
      <LineId Id="46" Count="12" />
      <LineId Id="43" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="45" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_DrehwinkelPruefung">
      <LineId Id="5" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_DrehzahlVorgabe">
      <LineId Id="5" Count="0" />
      <LineId Id="16" Count="2" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_SchraubtaktMessung">
      <LineId Id="32" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="39" Count="4" />
      <LineId Id="57" Count="9" />
      <LineId Id="82" Count="20" />
      <LineId Id="165" Count="3" />
      <LineId Id="103" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="104" Count="9" />
      <LineId Id="162" Count="2" />
      <LineId Id="135" Count="1" />
      <LineId Id="140" Count="0" />
      <LineId Id="143" Count="3" />
      <LineId Id="170" Count="0" />
      <LineId Id="147" Count="2" />
      <LineId Id="182" Count="1" />
      <LineId Id="150" Count="0" />
      <LineId Id="153" Count="3" />
      <LineId Id="171" Count="0" />
      <LineId Id="157" Count="2" />
      <LineId Id="138" Count="0" />
      <LineId Id="31" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_StillstandPruef">
      <LineId Id="26" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="2" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_TiefenAenderung">
      <LineId Id="50" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="112" Count="2" />
      <LineId Id="116" Count="14" />
      <LineId Id="115" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="89" Count="2" />
      <LineId Id="52" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="48" Count="0" />
    </LineIds>
    <LineIds Name="fb_SKSSchraubNob.m_TiefenPruefung">
      <LineId Id="17" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>