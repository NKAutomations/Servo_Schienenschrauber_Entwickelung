<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Schrauber_Simulation" Id="{12345678-1234-1234-1234-123456789012}" SpecialFunc="None">
    <Declaration><![CDATA[(*
SIMULATIONSBAUSTEIN FÜR SERVOSCHRAUBER
=======================================
Simuliert die Hardware-Komponenten für den Schraubertest:
- NC-Achse (Drehmotor)
- Encoder (Tiefenmessung)
- Zustellzylinder
- 4 verschiedene Schraubfälle

SCHRAUBFÄLLE:
1. Negative Toleranz & Drehmoment erreicht
2. Negative Toleranz & Solltiefe erreicht  
3. Positive Toleranz
4. Keine Schraube
*)
FUNCTION_BLOCK FB_Schrauber_Simulation
VAR_INPUT
    // Steuerung
    I_bSimulationEnable     : BOOL;          // Simulation aktivieren
    I_bReset                : BOOL;          // Reset der Simulation
    I_nSimulatedCase        : INT := 0;      // Zu simulierender Fall (0=Normal, 1-4=Fehlerfälle)
    
    // Parameter für Simulation
    I_fSollTiefe            : LREAL := -5.0; // Solltiefe in mm
    I_fMaxDrehzahl          : LREAL := 3000; // Max Drehzahl in U/min
    I_fMaxDrehmoment        : LREAL := 2.0;  // Max Drehmoment in Nm
    
    // Eingänge vom Schrauber-FB
    I_bSchraubHub           : BOOL;          // Schraubhub-Befehl
    I_bSchrAuswurf          : BOOL;          // Auswurf-Befehl
    I_nAchsId               : INT;           // Achsen-ID
    I_nEncId                : INT;           // Encoder-ID
END_VAR

VAR_OUTPUT
    // Simulierte Hardware-Ausgänge
    Q_bZustellZylAusgef     : BOOL;          // Zustellzylinder ausgefahren
    Q_bGrdstlgSchrEinh      : BOOL;          // Grundstellung erreicht
    Q_bSchutzbereichOK      : BOOL := TRUE;  // Schutzbereich OK
    
    // Debug-Ausgänge
    Q_fSimTiefe             : LREAL;         // Aktuelle simulierte Tiefe
    Q_fSimDrehmoment        : LREAL;         // Aktuelles simuliertes Drehmoment
    Q_fSimDrehzahl          : LREAL;         // Aktuelle simulierte Drehzahl
    Q_sDebugInfo            : STRING(255);   // Debug-Information
END_VAR

VAR
    // Interne Simulationsvariablen
    fAchsPosition           : LREAL;         // Simulierte Achsposition (Winkel)
    fTiefe                  : LREAL;         // Simulierte Tiefe
    fDrehmoment             : LREAL;         // Simuliertes Drehmoment
    fDrehzahl               : LREAL;         // Simulierte Drehzahl
    fZielDrehzahl           : LREAL;         // Ziel-Drehzahl
    
    // Timer für Simulation
    tonZylinder             : TON;           // Timer für Zylinderbewegung
    tonTiefenSimulation     : TON;           // Timer für Tiefenänderung
    tonDrehmomentAufbau     : TON;           // Timer für Drehmomentaufbau
    
    // Zustandsvariablen
    bSchraubeVorhanden      : BOOL := TRUE;  // Schraube vorhanden
    bMaterialHart           : BOOL;          // Hartes Material (höheres Drehmoment)
    bMaterialWeich          : BOOL;          // Weiches Material (niedrigeres Drehmoment)
    nSimulationStep         : INT;           // Interner Simulationsschritt
    
    // Einfache Rampen-Variablen (ohne externe Library)
    fDrehzahlRampe          : LREAL;         // Rampen-Zwischenwert Drehzahl
    fDrehmomentRampe        : LREAL;         // Rampen-Zwischenwert Drehmoment
    fRampeBeschleunigung    : LREAL := 50.0; // Beschleunigung U/min pro Zyklus
    fRampeBremsung          : LREAL := 100.0;// Bremsung U/min pro Zyklus
    fDrehmomentAnstieg      : LREAL := 0.02; // Drehmomentanstieg Nm pro Zyklus
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Simulation nur wenn aktiviert
IF NOT I_bSimulationEnable THEN
    RETURN;
END_IF

// Reset-Logik
IF I_bReset THEN
    ResetSimulation();
    RETURN;
END_IF

// Hauptsimulation
CASE nSimulationStep OF
    0: // Initialisierung
        InitializeSimulation();
        nSimulationStep := 10;
        
    10: // Warte auf Start
        Q_bGrdstlgSchrEinh := TRUE;
        Q_bZustellZylAusgef := FALSE;
        fTiefe := 80.0; // Startposition oben
        
        IF I_bSchraubHub THEN
            nSimulationStep := 20;
            Q_sDebugInfo := 'Zylinder fährt aus';
        END_IF
        
    20: // Zylinder ausfahren
        SimulateZylinder();
        
        IF Q_bZustellZylAusgef THEN
            nSimulationStep := 30;
            Q_sDebugInfo := 'Bereit zum Schrauben';
        END_IF
        
    30: // Schraubvorgang simulieren
        SimulateScrewing();
        
        // Zurück wenn Schraubhub weg
        IF NOT I_bSchraubHub THEN
            nSimulationStep := 40;
        END_IF
        
    40: // Rückfahrt
        SimulateRetraction();
        
        IF Q_bGrdstlgSchrEinh THEN
            nSimulationStep := 10;
        END_IF
END_CASE

// NC-Achsen Simulation updaten
UpdateNCAxes();

// Debug-Ausgänge
Q_fSimTiefe := fTiefe;
Q_fSimDrehmoment := fDrehmoment;
Q_fSimDrehzahl := fDrehzahl;]]></ST>
    </Implementation>
    <Method Name="InitializeSimulation" Id="{aaaaaaaa-1111-2222-3333-444444444444}">
      <Declaration><![CDATA[METHOD InitializeSimulation
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Simulationsparameter basierend auf gewähltem Fall setzen
CASE I_nSimulatedCase OF
    0: // Normalfall - alles OK
        bSchraubeVorhanden := TRUE;
        bMaterialHart := FALSE;
        bMaterialWeich := FALSE;
        Q_sDebugInfo := 'Simulation: Normalfall';
        
    1: // Fall 1: Negative Toleranz & Drehmoment erreicht
        bSchraubeVorhanden := TRUE;
        bMaterialHart := TRUE;
        bMaterialWeich := FALSE;
        Q_sDebugInfo := 'Simulation: Fall 1 - Hartes Material';
        
    2: // Fall 2: Negative Toleranz & Solltiefe erreicht
        bSchraubeVorhanden := TRUE;
        bMaterialHart := FALSE;
        bMaterialWeich := TRUE;
        Q_sDebugInfo := 'Simulation: Fall 2 - Weiches Material';
        
    3: // Fall 3: Positive Toleranz
        bSchraubeVorhanden := TRUE;
        bMaterialHart := FALSE;
        bMaterialWeich := FALSE;
        Q_sDebugInfo := 'Simulation: Fall 3 - Positive Toleranz';
        
    4: // Fall 4: Keine Schraube
        bSchraubeVorhanden := FALSE;
        bMaterialHart := FALSE;
        bMaterialWeich := FALSE;
        Q_sDebugInfo := 'Simulation: Fall 4 - Keine Schraube';
END_CASE

// Startwerte setzen
fAchsPosition := 0;
fTiefe := 80.0; // Startposition oben
fDrehmoment := 0;
fDrehzahl := 0;
fDrehzahlRampe := 0;
fDrehmomentRampe := 0;

// Rampenparameter setzen
fRampeBeschleunigung := 50.0;  // 50 U/min pro 10ms Zyklus = 5000 U/min/s
fRampeBremsung := 100.0;        // 100 U/min pro 10ms Zyklus = 10000 U/min/s
fDrehmomentAnstieg := 0.02;     // 0.02 Nm pro 10ms Zyklus = 2 Nm/s]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetSimulation" Id="{bbbbbbbb-2222-3333-4444-555555555555}">
      <Declaration><![CDATA[METHOD ResetSimulation
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Alle Variablen zurücksetzen
fAchsPosition := 0;
fTiefe := 80.0;
fDrehmoment := 0;
fDrehzahl := 0;
fZielDrehzahl := 0;

Q_bZustellZylAusgef := FALSE;
Q_bGrdstlgSchrEinh := TRUE;

nSimulationStep := 0;

// Timer zurücksetzen
tonZylinder(IN:=FALSE);
tonTiefenSimulation(IN:=FALSE);
tonDrehmomentAufbau(IN:=FALSE);

Q_sDebugInfo := 'Simulation zurückgesetzt';]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimulateZylinder" Id="{cccccccc-3333-4444-5555-666666666666}">
      <Declaration><![CDATA[METHOD SimulateZylinder
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Zylinderbewegung simulieren
tonZylinder(IN:=TRUE, PT:=T#500MS);

IF I_bSchrAuswurf THEN
    // Linear nach unten fahren während Auswurf
    IF fTiefe > 10.0 THEN
        fTiefe := fTiefe - 0.5; // 0.5mm pro Zyklus
    ELSE
        fTiefe := 10.0; // Aufsetzhöhe
    END_IF
END_IF

// Nach Timer ist Zylinder ausgefahren
IF tonZylinder.Q THEN
    Q_bZustellZylAusgef := TRUE;
    Q_bGrdstlgSchrEinh := FALSE;
    tonZylinder(IN:=FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimulateScrewing" Id="{dddddddd-4444-5555-6666-777777777777}">
      <Declaration><![CDATA[METHOD SimulateScrewing
VAR
    fTiefenGeschwindigkeit : LREAL;
    fDrehmomentZiel : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Drehzahl aus NC-Achse lesen
fZielDrehzahl := arrNcAchsen[I_nAchsId].stAuftrg.fPTP_Geschw * I_fMaxDrehzahl / 100;

// Einfache Drehzahlrampe implementieren
IF fDrehzahl < fZielDrehzahl THEN
    // Beschleunigen
    fDrehzahl := fDrehzahl + fRampeBeschleunigung;
    IF fDrehzahl > fZielDrehzahl THEN
        fDrehzahl := fZielDrehzahl; // Begrenzen auf Zielwert
    END_IF
ELSIF fDrehzahl > fZielDrehzahl THEN
    // Bremsen
    fDrehzahl := fDrehzahl - fRampeBremsung;
    IF fDrehzahl < fZielDrehzahl THEN
        fDrehzahl := fZielDrehzahl; // Begrenzen auf Zielwert
    END_IF
    IF fDrehzahl < 0 THEN
        fDrehzahl := 0; // Nicht negativ werden
    END_IF
END_IF

// Achsposition updaten (Winkel)
IF fDrehzahl > 0 THEN
    fAchsPosition := fAchsPosition + (fDrehzahl / 60 * 360 * 0.01); // 10ms Zykluszeit
END_IF

// Tiefensimulation basierend auf Fall
CASE I_nSimulatedCase OF
    0: // Normalfall
        fTiefenGeschwindigkeit := fDrehzahl / 1000; // Normal
        fDrehmomentZiel := 1.4; // Normales Drehmoment
        
    1: // Hartes Material
        fTiefenGeschwindigkeit := fDrehzahl / 2000; // Langsamer
        fDrehmomentZiel := 1.8; // Hohes Drehmoment
        
    2: // Weiches Material  
        fTiefenGeschwindigkeit := fDrehzahl / 800; // Schneller
        fDrehmomentZiel := 0.5; // Niedriges Drehmoment
        
    3: // Positive Toleranz
        fTiefenGeschwindigkeit := fDrehzahl / 1200;
        fDrehmomentZiel := 1.6;
        
    4: // Keine Schraube
        fTiefenGeschwindigkeit := fDrehzahl / 500; // Sehr schnell
        fDrehmomentZiel := 0.1; // Fast kein Drehmoment
END_CASE

// Tiefe ändern wenn Motor dreht
IF fDrehzahl > 10 AND I_bSchrAuswurf THEN
    IF bSchraubeVorhanden THEN
        // Mit Schraube - normale Geschwindigkeit
        IF fTiefe > I_fSollTiefe THEN
            fTiefe := fTiefe - fTiefenGeschwindigkeit;
            
            // Drehmoment aufbauen je nach Tiefe
            IF fTiefe < (I_fSollTiefe + 5) THEN
                // Kurz vor Ziel - Drehmoment steigt
                tonDrehmomentAufbau(IN:=TRUE, PT:=T#200MS);
                IF tonDrehmomentAufbau.Q OR fDrehmoment < fDrehmomentZiel THEN
                    fDrehmoment := fDrehmoment + fDrehmomentAnstieg;
                END_IF
            END_IF
        ELSE
            // Solltiefe erreicht
            fTiefe := I_fSollTiefe;
        END_IF
    ELSE
        // Ohne Schraube - fährt viel tiefer
        IF fTiefe > (I_fSollTiefe - 15) THEN
            fTiefe := fTiefe - fTiefenGeschwindigkeit * 2;
        END_IF
    END_IF
END_IF

// Drehmoment begrenzen
IF fDrehmoment > I_fMaxDrehmoment THEN
    fDrehmoment := I_fMaxDrehmoment;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SimulateRetraction" Id="{eeeeeeee-5555-6666-7777-888888888888}">
      <Declaration><![CDATA[METHOD SimulateRetraction
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Rückfahrt simulieren
Q_bZustellZylAusgef := FALSE;

// Tiefe zurückfahren
IF fTiefe < 80.0 THEN
    fTiefe := fTiefe + 1.0; // 1mm pro Zyklus hoch
ELSE
    fTiefe := 80.0;
    Q_bGrdstlgSchrEinh := TRUE;
END_IF

// Drehzahl auf 0
fDrehzahl := 0;
fDrehmoment := 0;

Q_sDebugInfo := 'Rückfahrt in Grundstellung';]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateNCAxes" Id="{ffffffff-6666-7777-8888-999999999999}">
      <Declaration><![CDATA[METHOD UpdateNCAxes
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// NC-Achsen-Strukturen mit Simulationswerten füllen
IF I_bSimulationEnable THEN
    
    // Encoder-Position (Tiefe)
    arrNcAchsen[I_nEncId].fPosIstwert := fTiefe;
    
    // Motor-Achse
    arrNcAchsen[I_nAchsId].fPosIstwert := fAchsPosition;
    arrNcAchsen[I_nAchsId].fVeloIstwert := fDrehzahl;
    
    // Drehmoment in 0.1% umrechnen (Annahme: 2Nm = 100%)
    arrNcAchsen[I_nAchsId].stEinAusG.I_nDrehmomentIstwert := LREAL_TO_INT(fDrehmoment / I_fMaxDrehmoment * 1000);
    
    // Status-Bits setzen
    arrNcAchsen[I_nAchsId].stStatus.bInStillst := (fDrehzahl < 1.0);
    arrNcAchsen[I_nAchsId].stStatus.bFaehrtPos := (fDrehzahl > 10.0);
    arrNcAchsen[I_nAchsId].stStatus.bFahrbewAkt := (fDrehzahl > 1.0);
    
    // Betriebsbereit
    arrNcAchsen[I_nAchsId].bBetrbBer := TRUE;
    arrNcAchsen[I_nAchsId].stAuftrg.bPTP_PosiFrg := TRUE;
    
    // Kein Fehler
    arrNcAchsen[I_nAchsId].bNcFehler := FALSE;
    arrNcAchsen[I_nAchsId].stEinAusG.I_nDCStatusword.13 := FALSE;
    
    // Signalstatuswort für Referenzierung
    IF nSimulationStep >= 30 THEN
        arrNcAchsen[I_nAchsId].stEinAusG.I_nSignalstatuswort.0 := TRUE;
    END_IF
    
    // Istwert gesetzt Rückmeldung
    IF arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_setz THEN
        arrNcAchsen[I_nAchsId].stGrdfkt.bIstw_gesetz := TRUE;
    END_IF
    
    // StartAusf Struktur simulieren
    IF arrStartAusf[I_nAchsId].I_bAchseZurArbP THEN
        // Achse läuft
        arrStartAusf[I_nAchsId].Q_bAchseInPos := FALSE;
        arrStartAusf[I_nAchsId].Q_bAchseGestPos := FALSE;
    END_IF
    
    IF arrStartAusf[I_nAchsId].I_bAchseStopPos THEN
        // Achse wurde gestoppt
        arrStartAusf[I_nAchsId].Q_bAchseGestPos := TRUE;
        arrStartAusf[I_nAchsId].Q_bAchseInPos := TRUE;
        fDrehzahl := 0;
    END_IF
    
    // In Position wenn stillsteht
    IF arrNcAchsen[I_nAchsId].stStatus.bInStillst THEN
        arrStartAusf[I_nAchsId].Q_bAchseInPos := TRUE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CalculateRamp" Id="{12121212-3434-5656-7878-909090909090}">
      <Declaration><![CDATA[METHOD PRIVATE CalculateRamp : LREAL
VAR_INPUT
    fActual     : LREAL;    // Aktueller Wert
    fTarget     : LREAL;    // Zielwert
    fRampUp     : LREAL;    // Anstiegsgeschwindigkeit
    fRampDown   : LREAL;    // Abstiegsgeschwindigkeit
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Einfache Rampenberechnung
IF fActual < fTarget THEN
    // Aufwärts
    CalculateRamp := fActual + fRampUp;
    IF CalculateRamp > fTarget THEN
        CalculateRamp := fTarget;
    END_IF
ELSIF fActual > fTarget THEN
    // Abwärts
    CalculateRamp := fActual - fRampDown;
    IF CalculateRamp < fTarget THEN
        CalculateRamp := fTarget;
    END_IF
ELSE
    // Ziel erreicht
    CalculateRamp := fTarget;
END_IF

// Begrenzung auf positive Werte
IF CalculateRamp < 0 THEN
    CalculateRamp := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>